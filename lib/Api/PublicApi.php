<?php
/**
 * PublicApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Rvvup
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Rvvup API
 *
 * Rvvup Public API
 *
 * The version of the OpenAPI document: 2024-03-01
 * Contact: info@rvvup.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Rvvup\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Rvvup\ApiException;
use Rvvup\Configuration;
use Rvvup\HeaderSelector;
use Rvvup\ObjectSerializer;

/**
 * PublicApi Class Doc Comment
 *
 * @category Class
 * @package  Rvvup
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PublicApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'applyCreditNote' => [
            'application/json',
        ],
        'createAccountStatement' => [
            'application/json',
        ],
        'createChaserPlan' => [
            'application/json',
        ],
        'createCheckout' => [
            'application/json',
        ],
        'createCheckoutTemplate' => [
            'application/json',
        ],
        'createConnection' => [
            'application/json',
        ],
        'createCreditNote' => [
            'application/json',
        ],
        'createCustomerAccount' => [
            'application/json',
        ],
        'createInvoice' => [
            'application/json',
        ],
        'createInvoiceNotification' => [
            'application/json',
        ],
        'createMerchantDomains' => [
            'application/json',
        ],
        'createNotificationSubscription' => [
            'application/json',
        ],
        'createPaymentLink' => [
            'application/json',
        ],
        'createPaymentSession' => [
            'application/json',
        ],
        'createRefund' => [
            'application/json',
        ],
        'createShipmentTracking' => [
            'application/json',
        ],
        'createShipmentTrackingWithCheckout' => [
            'application/json',
        ],
        'createTheme' => [
            'application/json',
        ],
        'createWebhook' => [
            'application/json',
        ],
        'deactivatePaymentLink' => [
            'application/json',
        ],
        'deleteCreditNote' => [
            'application/json',
        ],
        'deleteInvoice' => [
            'application/json',
        ],
        'deleteMerchantDomain' => [
            'application/json',
        ],
        'disconnectConnection' => [
            'application/json',
        ],
        'downloadCreditNote' => [
            'application/json',
        ],
        'downloadCreditNoteForInvoice' => [
            'application/json',
        ],
        'downloadInvoice' => [
            'application/json',
        ],
        'exportStatement' => [
            'application/json',
        ],
        'finalizeCreditNote' => [
            'application/json',
        ],
        'finalizeInvoice' => [
            'application/json',
        ],
        'getAccountStatement' => [
            'application/json',
        ],
        'getChaserPlan' => [
            'application/json',
        ],
        'getCheckout' => [
            'application/json',
        ],
        'getCheckoutForAccountStatement' => [
            'application/json',
        ],
        'getCheckoutForInvoice' => [
            'application/json',
        ],
        'getCheckoutTemplate' => [
            'application/json',
        ],
        'getConnection' => [
            'application/json',
        ],
        'getCreditNote' => [
            'application/json',
        ],
        'getCustomerAccount' => [
            'application/json',
        ],
        'getCustomerAccounts' => [
            'application/json',
        ],
        'getInvoice' => [
            'application/json',
        ],
        'getNotificationSubscription' => [
            'application/json',
        ],
        'getOrderById' => [
            'application/json',
        ],
        'getOrders' => [
            'application/json',
        ],
        'getPaymentLink' => [
            'application/json',
        ],
        'getPaymentSession' => [
            'application/json',
        ],
        'getPaymentSettings' => [
            'application/json',
        ],
        'getTheme' => [
            'application/json',
        ],
        'getThemeForAccountStatement' => [
            'application/json',
        ],
        'getThemeForCheckout' => [
            'application/json',
        ],
        'getWebhook' => [
            'application/json',
        ],
        'listChaserPlans' => [
            'application/json',
        ],
        'listCheckoutPaymentMethods' => [
            'application/json',
        ],
        'listCheckoutTemplates' => [
            'application/json',
        ],
        'listCheckouts' => [
            'application/json',
        ],
        'listConnections' => [
            'application/json',
        ],
        'listCreditNotes' => [
            'application/json',
        ],
        'listCreditNotesForInvoice' => [
            'application/json',
        ],
        'listInvoiceNotifications' => [
            'application/json',
        ],
        'listInvoices' => [
            'application/json',
        ],
        'listInvoicesForCustomerAccount' => [
            'application/json',
        ],
        'listMerchantDomains' => [
            'application/json',
        ],
        'listNotificationSubscriptions' => [
            'application/json',
        ],
        'listPaymentLinks' => [
            'application/json',
        ],
        'listPaymentMethods' => [
            'application/json',
        ],
        'listThemes' => [
            'application/json',
        ],
        'listWebhooks' => [
            'application/json',
        ],
        'refreshInvoiceUrl' => [
            'application/json',
        ],
        'updateCheckoutTemplate' => [
            'application/json',
        ],
        'updateCreditNote' => [
            'application/json',
        ],
        'updateInvoice' => [
            'application/json',
        ],
        'updateTheme' => [
            'application/json',
        ],
        'updateWebhook' => [
            'application/json',
        ],
        'voidCreditNote' => [
            'application/json',
        ],
        'voidInvoice' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation applyCreditNote
     *
     * Apply a credit note to an invoice
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['applyCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNote
     */
    public function applyCreditNote($credit_note_id, $merchant_id, string $contentType = self::contentTypes['applyCreditNote'][0])
    {
        list($response) = $this->applyCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation applyCreditNoteWithHttpInfo
     *
     * Apply a credit note to an invoice
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['applyCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function applyCreditNoteWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['applyCreditNote'][0])
    {
        $request = $this->applyCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNote' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation applyCreditNoteAsync
     *
     * Apply a credit note to an invoice
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['applyCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applyCreditNoteAsync($credit_note_id, $merchant_id, string $contentType = self::contentTypes['applyCreditNote'][0])
    {
        return $this->applyCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation applyCreditNoteAsyncWithHttpInfo
     *
     * Apply a credit note to an invoice
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['applyCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applyCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['applyCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNote';
        $request = $this->applyCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'applyCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['applyCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function applyCreditNoteRequest($credit_note_id, $merchant_id, string $contentType = self::contentTypes['applyCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling applyCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling applyCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}/apply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAccountStatement
     *
     * Create a new account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\AccountStatementCreateInput $account_statement_create_input The account statement to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\AccountStatement
     */
    public function createAccountStatement($merchant_id, $account_statement_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createAccountStatement'][0])
    {
        list($response) = $this->createAccountStatementWithHttpInfo($merchant_id, $account_statement_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createAccountStatementWithHttpInfo
     *
     * Create a new account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\AccountStatementCreateInput $account_statement_create_input The account statement to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\AccountStatement, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountStatementWithHttpInfo($merchant_id, $account_statement_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createAccountStatement'][0])
    {
        $request = $this->createAccountStatementRequest($merchant_id, $account_statement_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\AccountStatement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\AccountStatement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\AccountStatement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\AccountStatement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\AccountStatement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountStatementAsync
     *
     * Create a new account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\AccountStatementCreateInput $account_statement_create_input The account statement to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountStatementAsync($merchant_id, $account_statement_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createAccountStatement'][0])
    {
        return $this->createAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountStatementAsyncWithHttpInfo
     *
     * Create a new account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\AccountStatementCreateInput $account_statement_create_input The account statement to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createAccountStatement'][0])
    {
        $returnType = '\Rvvup\Api\Model\AccountStatement';
        $request = $this->createAccountStatementRequest($merchant_id, $account_statement_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountStatement'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\AccountStatementCreateInput $account_statement_create_input The account statement to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAccountStatementRequest($merchant_id, $account_statement_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createAccountStatement'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createAccountStatement'
            );
        }

        // verify the required parameter 'account_statement_create_input' is set
        if ($account_statement_create_input === null || (is_array($account_statement_create_input) && count($account_statement_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_statement_create_input when calling createAccountStatement'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/accounts/statements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($account_statement_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($account_statement_create_input));
            } else {
                $httpBody = $account_statement_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createChaserPlan
     *
     * Create new chaser plan
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\ChaserPlanCreateInput $chaser_plan_create_input The chaser plan to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChaserPlan'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ChaserPlan
     */
    public function createChaserPlan($merchant_id, $chaser_plan_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createChaserPlan'][0])
    {
        list($response) = $this->createChaserPlanWithHttpInfo($merchant_id, $chaser_plan_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createChaserPlanWithHttpInfo
     *
     * Create new chaser plan
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\ChaserPlanCreateInput $chaser_plan_create_input The chaser plan to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChaserPlan'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ChaserPlan, HTTP status code, HTTP response headers (array of strings)
     */
    public function createChaserPlanWithHttpInfo($merchant_id, $chaser_plan_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createChaserPlan'][0])
    {
        $request = $this->createChaserPlanRequest($merchant_id, $chaser_plan_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ChaserPlan' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ChaserPlan' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ChaserPlan', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ChaserPlan';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ChaserPlan',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createChaserPlanAsync
     *
     * Create new chaser plan
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\ChaserPlanCreateInput $chaser_plan_create_input The chaser plan to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChaserPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createChaserPlanAsync($merchant_id, $chaser_plan_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createChaserPlan'][0])
    {
        return $this->createChaserPlanAsyncWithHttpInfo($merchant_id, $chaser_plan_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createChaserPlanAsyncWithHttpInfo
     *
     * Create new chaser plan
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\ChaserPlanCreateInput $chaser_plan_create_input The chaser plan to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChaserPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createChaserPlanAsyncWithHttpInfo($merchant_id, $chaser_plan_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createChaserPlan'][0])
    {
        $returnType = '\Rvvup\Api\Model\ChaserPlan';
        $request = $this->createChaserPlanRequest($merchant_id, $chaser_plan_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createChaserPlan'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\ChaserPlanCreateInput $chaser_plan_create_input The chaser plan to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChaserPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createChaserPlanRequest($merchant_id, $chaser_plan_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createChaserPlan'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createChaserPlan'
            );
        }

        // verify the required parameter 'chaser_plan_create_input' is set
        if ($chaser_plan_create_input === null || (is_array($chaser_plan_create_input) && count($chaser_plan_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chaser_plan_create_input when calling createChaserPlan'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/chaser-plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($chaser_plan_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($chaser_plan_create_input));
            } else {
                $httpBody = $chaser_plan_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCheckout
     *
     * Create new checkout
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutCreateInput $checkout_create_input The Checkout to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Checkout
     */
    public function createCheckout($merchant_id, $checkout_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCheckout'][0])
    {
        list($response) = $this->createCheckoutWithHttpInfo($merchant_id, $checkout_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createCheckoutWithHttpInfo
     *
     * Create new checkout
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutCreateInput $checkout_create_input The Checkout to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Checkout, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCheckoutWithHttpInfo($merchant_id, $checkout_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCheckout'][0])
    {
        $request = $this->createCheckoutRequest($merchant_id, $checkout_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Checkout' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Checkout' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Checkout', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Checkout';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Checkout',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCheckoutAsync
     *
     * Create new checkout
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutCreateInput $checkout_create_input The Checkout to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCheckoutAsync($merchant_id, $checkout_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCheckout'][0])
    {
        return $this->createCheckoutAsyncWithHttpInfo($merchant_id, $checkout_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCheckoutAsyncWithHttpInfo
     *
     * Create new checkout
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutCreateInput $checkout_create_input The Checkout to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCheckoutAsyncWithHttpInfo($merchant_id, $checkout_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCheckout'][0])
    {
        $returnType = '\Rvvup\Api\Model\Checkout';
        $request = $this->createCheckoutRequest($merchant_id, $checkout_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCheckout'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutCreateInput $checkout_create_input The Checkout to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCheckoutRequest($merchant_id, $checkout_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCheckout'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createCheckout'
            );
        }

        // verify the required parameter 'checkout_create_input' is set
        if ($checkout_create_input === null || (is_array($checkout_create_input) && count($checkout_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_create_input when calling createCheckout'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($checkout_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($checkout_create_input));
            } else {
                $httpBody = $checkout_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCheckoutTemplate
     *
     * Create new checkout template
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateCreateInput $checkout_template_create_input The checkout template to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CheckoutTemplate
     */
    public function createCheckoutTemplate($merchant_id, $checkout_template_create_input, string $contentType = self::contentTypes['createCheckoutTemplate'][0])
    {
        list($response) = $this->createCheckoutTemplateWithHttpInfo($merchant_id, $checkout_template_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createCheckoutTemplateWithHttpInfo
     *
     * Create new checkout template
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateCreateInput $checkout_template_create_input The checkout template to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CheckoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCheckoutTemplateWithHttpInfo($merchant_id, $checkout_template_create_input, string $contentType = self::contentTypes['createCheckoutTemplate'][0])
    {
        $request = $this->createCheckoutTemplateRequest($merchant_id, $checkout_template_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CheckoutTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CheckoutTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CheckoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CheckoutTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CheckoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCheckoutTemplateAsync
     *
     * Create new checkout template
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateCreateInput $checkout_template_create_input The checkout template to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCheckoutTemplateAsync($merchant_id, $checkout_template_create_input, string $contentType = self::contentTypes['createCheckoutTemplate'][0])
    {
        return $this->createCheckoutTemplateAsyncWithHttpInfo($merchant_id, $checkout_template_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCheckoutTemplateAsyncWithHttpInfo
     *
     * Create new checkout template
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateCreateInput $checkout_template_create_input The checkout template to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCheckoutTemplateAsyncWithHttpInfo($merchant_id, $checkout_template_create_input, string $contentType = self::contentTypes['createCheckoutTemplate'][0])
    {
        $returnType = '\Rvvup\Api\Model\CheckoutTemplate';
        $request = $this->createCheckoutTemplateRequest($merchant_id, $checkout_template_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCheckoutTemplate'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateCreateInput $checkout_template_create_input The checkout template to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCheckoutTemplateRequest($merchant_id, $checkout_template_create_input, string $contentType = self::contentTypes['createCheckoutTemplate'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createCheckoutTemplate'
            );
        }

        // verify the required parameter 'checkout_template_create_input' is set
        if ($checkout_template_create_input === null || (is_array($checkout_template_create_input) && count($checkout_template_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_template_create_input when calling createCheckoutTemplate'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkout-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($checkout_template_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($checkout_template_create_input));
            } else {
                $httpBody = $checkout_template_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConnection
     *
     * Create a new connection or updates an existing connection.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ConnectionCreateInput $connection_create_input The connection to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnection'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Connection
     */
    public function createConnection($merchant_id, $connection_create_input, string $contentType = self::contentTypes['createConnection'][0])
    {
        list($response) = $this->createConnectionWithHttpInfo($merchant_id, $connection_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createConnectionWithHttpInfo
     *
     * Create a new connection or updates an existing connection.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ConnectionCreateInput $connection_create_input The connection to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnection'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Connection, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConnectionWithHttpInfo($merchant_id, $connection_create_input, string $contentType = self::contentTypes['createConnection'][0])
    {
        $request = $this->createConnectionRequest($merchant_id, $connection_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Connection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Connection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Connection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Connection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Connection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConnectionAsync
     *
     * Create a new connection or updates an existing connection.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ConnectionCreateInput $connection_create_input The connection to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectionAsync($merchant_id, $connection_create_input, string $contentType = self::contentTypes['createConnection'][0])
    {
        return $this->createConnectionAsyncWithHttpInfo($merchant_id, $connection_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConnectionAsyncWithHttpInfo
     *
     * Create a new connection or updates an existing connection.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ConnectionCreateInput $connection_create_input The connection to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectionAsyncWithHttpInfo($merchant_id, $connection_create_input, string $contentType = self::contentTypes['createConnection'][0])
    {
        $returnType = '\Rvvup\Api\Model\Connection';
        $request = $this->createConnectionRequest($merchant_id, $connection_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConnection'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ConnectionCreateInput $connection_create_input The connection to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConnectionRequest($merchant_id, $connection_create_input, string $contentType = self::contentTypes['createConnection'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createConnection'
            );
        }

        // verify the required parameter 'connection_create_input' is set
        if ($connection_create_input === null || (is_array($connection_create_input) && count($connection_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_create_input when calling createConnection'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connection_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connection_create_input));
            } else {
                $httpBody = $connection_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCreditNote
     *
     * Create new credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteCreateInput $credit_note_create_input The credit note to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNote
     */
    public function createCreditNote($merchant_id, $credit_note_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCreditNote'][0])
    {
        list($response) = $this->createCreditNoteWithHttpInfo($merchant_id, $credit_note_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createCreditNoteWithHttpInfo
     *
     * Create new credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteCreateInput $credit_note_create_input The credit note to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCreditNoteWithHttpInfo($merchant_id, $credit_note_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCreditNote'][0])
    {
        $request = $this->createCreditNoteRequest($merchant_id, $credit_note_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNote' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCreditNoteAsync
     *
     * Create new credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteCreateInput $credit_note_create_input The credit note to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAsync($merchant_id, $credit_note_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCreditNote'][0])
    {
        return $this->createCreditNoteAsyncWithHttpInfo($merchant_id, $credit_note_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCreditNoteAsyncWithHttpInfo
     *
     * Create new credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteCreateInput $credit_note_create_input The credit note to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCreditNoteAsyncWithHttpInfo($merchant_id, $credit_note_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNote';
        $request = $this->createCreditNoteRequest($merchant_id, $credit_note_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCreditNote'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteCreateInput $credit_note_create_input The credit note to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCreditNoteRequest($merchant_id, $credit_note_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createCreditNote'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createCreditNote'
            );
        }

        // verify the required parameter 'credit_note_create_input' is set
        if ($credit_note_create_input === null || (is_array($credit_note_create_input) && count($credit_note_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_create_input when calling createCreditNote'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credit_note_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credit_note_create_input));
            } else {
                $httpBody = $credit_note_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCustomerAccount
     *
     * Create a customer account
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CustomerAccountCreateInput $customer_account_create_input The Customer Account to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomerAccount'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CustomerAccount
     */
    public function createCustomerAccount($merchant_id, $customer_account_create_input, string $contentType = self::contentTypes['createCustomerAccount'][0])
    {
        list($response) = $this->createCustomerAccountWithHttpInfo($merchant_id, $customer_account_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createCustomerAccountWithHttpInfo
     *
     * Create a customer account
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CustomerAccountCreateInput $customer_account_create_input The Customer Account to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomerAccount'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CustomerAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCustomerAccountWithHttpInfo($merchant_id, $customer_account_create_input, string $contentType = self::contentTypes['createCustomerAccount'][0])
    {
        $request = $this->createCustomerAccountRequest($merchant_id, $customer_account_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CustomerAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CustomerAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CustomerAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CustomerAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CustomerAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCustomerAccountAsync
     *
     * Create a customer account
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CustomerAccountCreateInput $customer_account_create_input The Customer Account to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomerAccountAsync($merchant_id, $customer_account_create_input, string $contentType = self::contentTypes['createCustomerAccount'][0])
    {
        return $this->createCustomerAccountAsyncWithHttpInfo($merchant_id, $customer_account_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCustomerAccountAsyncWithHttpInfo
     *
     * Create a customer account
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CustomerAccountCreateInput $customer_account_create_input The Customer Account to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCustomerAccountAsyncWithHttpInfo($merchant_id, $customer_account_create_input, string $contentType = self::contentTypes['createCustomerAccount'][0])
    {
        $returnType = '\Rvvup\Api\Model\CustomerAccount';
        $request = $this->createCustomerAccountRequest($merchant_id, $customer_account_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCustomerAccount'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CustomerAccountCreateInput $customer_account_create_input The Customer Account to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCustomerAccountRequest($merchant_id, $customer_account_create_input, string $contentType = self::contentTypes['createCustomerAccount'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createCustomerAccount'
            );
        }

        // verify the required parameter 'customer_account_create_input' is set
        if ($customer_account_create_input === null || (is_array($customer_account_create_input) && count($customer_account_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_account_create_input when calling createCustomerAccount'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/customer-accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer_account_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer_account_create_input));
            } else {
                $httpBody = $customer_account_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInvoice
     *
     * Create new invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceCreateInput $invoice_create_input The invoice to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Invoice
     */
    public function createInvoice($merchant_id, $invoice_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        list($response) = $this->createInvoiceWithHttpInfo($merchant_id, $invoice_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createInvoiceWithHttpInfo
     *
     * Create new invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceCreateInput $invoice_create_input The invoice to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceWithHttpInfo($merchant_id, $invoice_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        $request = $this->createInvoiceRequest($merchant_id, $invoice_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Invoice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Invoice' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Invoice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Invoice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceAsync
     *
     * Create new invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceCreateInput $invoice_create_input The invoice to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAsync($merchant_id, $invoice_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        return $this->createInvoiceAsyncWithHttpInfo($merchant_id, $invoice_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceAsyncWithHttpInfo
     *
     * Create new invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceCreateInput $invoice_create_input The invoice to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceAsyncWithHttpInfo($merchant_id, $invoice_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\Invoice';
        $request = $this->createInvoiceRequest($merchant_id, $invoice_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoice'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceCreateInput $invoice_create_input The invoice to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createInvoiceRequest($merchant_id, $invoice_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createInvoice'
            );
        }

        // verify the required parameter 'invoice_create_input' is set
        if ($invoice_create_input === null || (is_array($invoice_create_input) && count($invoice_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_create_input when calling createInvoice'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_create_input));
            } else {
                $httpBody = $invoice_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInvoiceNotification
     *
     * Notify a customer of an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceNotificationInput $invoice_notification_input The notification request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoiceNotification'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\InvoiceNotification
     */
    public function createInvoiceNotification($invoice_id, $merchant_id, $invoice_notification_input, string $contentType = self::contentTypes['createInvoiceNotification'][0])
    {
        list($response) = $this->createInvoiceNotificationWithHttpInfo($invoice_id, $merchant_id, $invoice_notification_input, $contentType);
        return $response;
    }

    /**
     * Operation createInvoiceNotificationWithHttpInfo
     *
     * Notify a customer of an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceNotificationInput $invoice_notification_input The notification request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoiceNotification'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\InvoiceNotification, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInvoiceNotificationWithHttpInfo($invoice_id, $merchant_id, $invoice_notification_input, string $contentType = self::contentTypes['createInvoiceNotification'][0])
    {
        $request = $this->createInvoiceNotificationRequest($invoice_id, $merchant_id, $invoice_notification_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\InvoiceNotification' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\InvoiceNotification' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\InvoiceNotification', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\InvoiceNotification';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\InvoiceNotification',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createInvoiceNotificationAsync
     *
     * Notify a customer of an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceNotificationInput $invoice_notification_input The notification request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoiceNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceNotificationAsync($invoice_id, $merchant_id, $invoice_notification_input, string $contentType = self::contentTypes['createInvoiceNotification'][0])
    {
        return $this->createInvoiceNotificationAsyncWithHttpInfo($invoice_id, $merchant_id, $invoice_notification_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInvoiceNotificationAsyncWithHttpInfo
     *
     * Notify a customer of an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceNotificationInput $invoice_notification_input The notification request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoiceNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInvoiceNotificationAsyncWithHttpInfo($invoice_id, $merchant_id, $invoice_notification_input, string $contentType = self::contentTypes['createInvoiceNotification'][0])
    {
        $returnType = '\Rvvup\Api\Model\InvoiceNotification';
        $request = $this->createInvoiceNotificationRequest($invoice_id, $merchant_id, $invoice_notification_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInvoiceNotification'
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\InvoiceNotificationInput $invoice_notification_input The notification request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInvoiceNotification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createInvoiceNotificationRequest($invoice_id, $merchant_id, $invoice_notification_input, string $contentType = self::contentTypes['createInvoiceNotification'][0])
    {

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling createInvoiceNotification'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createInvoiceNotification'
            );
        }

        // verify the required parameter 'invoice_notification_input' is set
        if ($invoice_notification_input === null || (is_array($invoice_notification_input) && count($invoice_notification_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_notification_input when calling createInvoiceNotification'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/notifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_notification_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_notification_input));
            } else {
                $httpBody = $invoice_notification_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMerchantDomains
     *
     * Create new merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\MerchantDomainsCreateInput $merchant_domains_create_input Input for adding new domains to the merchant (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMerchantDomains'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\MerchantDomainsPage
     */
    public function createMerchantDomains($merchant_id, $merchant_domains_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createMerchantDomains'][0])
    {
        list($response) = $this->createMerchantDomainsWithHttpInfo($merchant_id, $merchant_domains_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createMerchantDomainsWithHttpInfo
     *
     * Create new merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\MerchantDomainsCreateInput $merchant_domains_create_input Input for adding new domains to the merchant (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMerchantDomains'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\MerchantDomainsPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMerchantDomainsWithHttpInfo($merchant_id, $merchant_domains_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createMerchantDomains'][0])
    {
        $request = $this->createMerchantDomainsRequest($merchant_id, $merchant_domains_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\MerchantDomainsPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\MerchantDomainsPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\MerchantDomainsPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\MerchantDomainsPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\MerchantDomainsPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createMerchantDomainsAsync
     *
     * Create new merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\MerchantDomainsCreateInput $merchant_domains_create_input Input for adding new domains to the merchant (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMerchantDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMerchantDomainsAsync($merchant_id, $merchant_domains_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createMerchantDomains'][0])
    {
        return $this->createMerchantDomainsAsyncWithHttpInfo($merchant_id, $merchant_domains_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMerchantDomainsAsyncWithHttpInfo
     *
     * Create new merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\MerchantDomainsCreateInput $merchant_domains_create_input Input for adding new domains to the merchant (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMerchantDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMerchantDomainsAsyncWithHttpInfo($merchant_id, $merchant_domains_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createMerchantDomains'][0])
    {
        $returnType = '\Rvvup\Api\Model\MerchantDomainsPage';
        $request = $this->createMerchantDomainsRequest($merchant_id, $merchant_domains_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMerchantDomains'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\MerchantDomainsCreateInput $merchant_domains_create_input Input for adding new domains to the merchant (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMerchantDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMerchantDomainsRequest($merchant_id, $merchant_domains_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createMerchantDomains'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createMerchantDomains'
            );
        }

        // verify the required parameter 'merchant_domains_create_input' is set
        if ($merchant_domains_create_input === null || (is_array($merchant_domains_create_input) && count($merchant_domains_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_domains_create_input when calling createMerchantDomains'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($merchant_domains_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($merchant_domains_create_input));
            } else {
                $httpBody = $merchant_domains_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNotificationSubscription
     *
     * Create a new notification subscription.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\NotificationSubscriptionCreateInput $notification_subscription_create_input The notification subscription to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\NotificationSubscription
     */
    public function createNotificationSubscription($merchant_id, $notification_subscription_create_input, string $contentType = self::contentTypes['createNotificationSubscription'][0])
    {
        list($response) = $this->createNotificationSubscriptionWithHttpInfo($merchant_id, $notification_subscription_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createNotificationSubscriptionWithHttpInfo
     *
     * Create a new notification subscription.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\NotificationSubscriptionCreateInput $notification_subscription_create_input The notification subscription to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\NotificationSubscription, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNotificationSubscriptionWithHttpInfo($merchant_id, $notification_subscription_create_input, string $contentType = self::contentTypes['createNotificationSubscription'][0])
    {
        $request = $this->createNotificationSubscriptionRequest($merchant_id, $notification_subscription_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\NotificationSubscription' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\NotificationSubscription' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\NotificationSubscription', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\NotificationSubscription';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\NotificationSubscription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNotificationSubscriptionAsync
     *
     * Create a new notification subscription.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\NotificationSubscriptionCreateInput $notification_subscription_create_input The notification subscription to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNotificationSubscriptionAsync($merchant_id, $notification_subscription_create_input, string $contentType = self::contentTypes['createNotificationSubscription'][0])
    {
        return $this->createNotificationSubscriptionAsyncWithHttpInfo($merchant_id, $notification_subscription_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNotificationSubscriptionAsyncWithHttpInfo
     *
     * Create a new notification subscription.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\NotificationSubscriptionCreateInput $notification_subscription_create_input The notification subscription to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNotificationSubscriptionAsyncWithHttpInfo($merchant_id, $notification_subscription_create_input, string $contentType = self::contentTypes['createNotificationSubscription'][0])
    {
        $returnType = '\Rvvup\Api\Model\NotificationSubscription';
        $request = $this->createNotificationSubscriptionRequest($merchant_id, $notification_subscription_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNotificationSubscription'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\NotificationSubscriptionCreateInput $notification_subscription_create_input The notification subscription to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNotificationSubscriptionRequest($merchant_id, $notification_subscription_create_input, string $contentType = self::contentTypes['createNotificationSubscription'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createNotificationSubscription'
            );
        }

        // verify the required parameter 'notification_subscription_create_input' is set
        if ($notification_subscription_create_input === null || (is_array($notification_subscription_create_input) && count($notification_subscription_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $notification_subscription_create_input when calling createNotificationSubscription'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/notification-subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($notification_subscription_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($notification_subscription_create_input));
            } else {
                $httpBody = $notification_subscription_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPaymentLink
     *
     * Create new payment link
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentLinkCreateInput $payment_link_create_input The Payment Link to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentLink'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentLink
     */
    public function createPaymentLink($merchant_id, $payment_link_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createPaymentLink'][0])
    {
        list($response) = $this->createPaymentLinkWithHttpInfo($merchant_id, $payment_link_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createPaymentLinkWithHttpInfo
     *
     * Create new payment link
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentLinkCreateInput $payment_link_create_input The Payment Link to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentLink'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentLinkWithHttpInfo($merchant_id, $payment_link_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createPaymentLink'][0])
    {
        $request = $this->createPaymentLinkRequest($merchant_id, $payment_link_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentLinkAsync
     *
     * Create new payment link
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentLinkCreateInput $payment_link_create_input The Payment Link to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentLinkAsync($merchant_id, $payment_link_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createPaymentLink'][0])
    {
        return $this->createPaymentLinkAsyncWithHttpInfo($merchant_id, $payment_link_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentLinkAsyncWithHttpInfo
     *
     * Create new payment link
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentLinkCreateInput $payment_link_create_input The Payment Link to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentLinkAsyncWithHttpInfo($merchant_id, $payment_link_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createPaymentLink'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentLink';
        $request = $this->createPaymentLinkRequest($merchant_id, $payment_link_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPaymentLink'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentLinkCreateInput $payment_link_create_input The Payment Link to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPaymentLinkRequest($merchant_id, $payment_link_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createPaymentLink'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createPaymentLink'
            );
        }

        // verify the required parameter 'payment_link_create_input' is set
        if ($payment_link_create_input === null || (is_array($payment_link_create_input) && count($payment_link_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_link_create_input when calling createPaymentLink'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/payment-links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_link_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_link_create_input));
            } else {
                $httpBody = $payment_link_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPaymentSession
     *
     * Create a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\PaymentSessionCreateInput $payment_session_create_input The Payment Session to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentSession
     */
    public function createPaymentSession($merchant_id, $checkout_id, $payment_session_create_input, string $contentType = self::contentTypes['createPaymentSession'][0])
    {
        list($response) = $this->createPaymentSessionWithHttpInfo($merchant_id, $checkout_id, $payment_session_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createPaymentSessionWithHttpInfo
     *
     * Create a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\PaymentSessionCreateInput $payment_session_create_input The Payment Session to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentSession, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPaymentSessionWithHttpInfo($merchant_id, $checkout_id, $payment_session_create_input, string $contentType = self::contentTypes['createPaymentSession'][0])
    {
        $request = $this->createPaymentSessionRequest($merchant_id, $checkout_id, $payment_session_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentSession' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentSession' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentSession', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentSession';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createPaymentSessionAsync
     *
     * Create a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\PaymentSessionCreateInput $payment_session_create_input The Payment Session to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentSessionAsync($merchant_id, $checkout_id, $payment_session_create_input, string $contentType = self::contentTypes['createPaymentSession'][0])
    {
        return $this->createPaymentSessionAsyncWithHttpInfo($merchant_id, $checkout_id, $payment_session_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createPaymentSessionAsyncWithHttpInfo
     *
     * Create a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\PaymentSessionCreateInput $payment_session_create_input The Payment Session to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createPaymentSessionAsyncWithHttpInfo($merchant_id, $checkout_id, $payment_session_create_input, string $contentType = self::contentTypes['createPaymentSession'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentSession';
        $request = $this->createPaymentSessionRequest($merchant_id, $checkout_id, $payment_session_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createPaymentSession'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\PaymentSessionCreateInput $payment_session_create_input The Payment Session to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createPaymentSessionRequest($merchant_id, $checkout_id, $payment_session_create_input, string $contentType = self::contentTypes['createPaymentSession'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createPaymentSession'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling createPaymentSession'
            );
        }

        // verify the required parameter 'payment_session_create_input' is set
        if ($payment_session_create_input === null || (is_array($payment_session_create_input) && count($payment_session_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_session_create_input when calling createPaymentSession'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}/payment-sessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_session_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_session_create_input));
            } else {
                $httpBody = $payment_session_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRefund
     *
     * Create a refund
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $checkout_id The checkout id (required)
     * @param  string $payment_session_id The payment session id (required)
     * @param  \Rvvup\Api\Model\RefundCreateInput $refund_create_input The refund to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Refund
     */
    public function createRefund($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createRefund'][0])
    {
        list($response) = $this->createRefundWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key, $contentType);
        return $response;
    }

    /**
     * Operation createRefundWithHttpInfo
     *
     * Create a refund
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $checkout_id The checkout id (required)
     * @param  string $payment_session_id The payment session id (required)
     * @param  \Rvvup\Api\Model\RefundCreateInput $refund_create_input The refund to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Refund, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRefundWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createRefund'][0])
    {
        $request = $this->createRefundRequest($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Refund' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Refund' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Refund', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Refund';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Refund',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRefundAsync
     *
     * Create a refund
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $checkout_id The checkout id (required)
     * @param  string $payment_session_id The payment session id (required)
     * @param  \Rvvup\Api\Model\RefundCreateInput $refund_create_input The refund to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRefundAsync($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createRefund'][0])
    {
        return $this->createRefundAsyncWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRefundAsyncWithHttpInfo
     *
     * Create a refund
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $checkout_id The checkout id (required)
     * @param  string $payment_session_id The payment session id (required)
     * @param  \Rvvup\Api\Model\RefundCreateInput $refund_create_input The refund to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRefundAsyncWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createRefund'][0])
    {
        $returnType = '\Rvvup\Api\Model\Refund';
        $request = $this->createRefundRequest($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRefund'
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $checkout_id The checkout id (required)
     * @param  string $payment_session_id The payment session id (required)
     * @param  \Rvvup\Api\Model\RefundCreateInput $refund_create_input The refund to create (required)
     * @param  string $idempotency_key Idempotency Key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRefundRequest($merchant_id, $checkout_id, $payment_session_id, $refund_create_input, $idempotency_key = null, string $contentType = self::contentTypes['createRefund'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createRefund'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling createRefund'
            );
        }

        // verify the required parameter 'payment_session_id' is set
        if ($payment_session_id === null || (is_array($payment_session_id) && count($payment_session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_session_id when calling createRefund'
            );
        }

        // verify the required parameter 'refund_create_input' is set
        if ($refund_create_input === null || (is_array($refund_create_input) && count($refund_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $refund_create_input when calling createRefund'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}/payment-sessions/{paymentSessionId}/refunds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($idempotency_key !== null) {
            $headerParams['Idempotency-Key'] = ObjectSerializer::toHeaderValue($idempotency_key);
        }

        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }
        // path params
        if ($payment_session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentSessionId' . '}',
                ObjectSerializer::toPathValue($payment_session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($refund_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($refund_create_input));
            } else {
                $httpBody = $refund_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShipmentTracking
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTracking'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ShipmentTracking
     */
    public function createShipmentTracking($merchant_id, $payment_session_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTracking'][0])
    {
        list($response) = $this->createShipmentTrackingWithHttpInfo($merchant_id, $payment_session_id, $shipment_tracking_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createShipmentTrackingWithHttpInfo
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTracking'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ShipmentTracking, HTTP status code, HTTP response headers (array of strings)
     */
    public function createShipmentTrackingWithHttpInfo($merchant_id, $payment_session_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTracking'][0])
    {
        $request = $this->createShipmentTrackingRequest($merchant_id, $payment_session_id, $shipment_tracking_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ShipmentTracking' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ShipmentTracking' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ShipmentTracking', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ShipmentTracking';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ShipmentTracking',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createShipmentTrackingAsync
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTracking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentTrackingAsync($merchant_id, $payment_session_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTracking'][0])
    {
        return $this->createShipmentTrackingAsyncWithHttpInfo($merchant_id, $payment_session_id, $shipment_tracking_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShipmentTrackingAsyncWithHttpInfo
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTracking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentTrackingAsyncWithHttpInfo($merchant_id, $payment_session_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTracking'][0])
    {
        $returnType = '\Rvvup\Api\Model\ShipmentTracking';
        $request = $this->createShipmentTrackingRequest($merchant_id, $payment_session_id, $shipment_tracking_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShipmentTracking'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTracking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createShipmentTrackingRequest($merchant_id, $payment_session_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTracking'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createShipmentTracking'
            );
        }

        // verify the required parameter 'payment_session_id' is set
        if ($payment_session_id === null || (is_array($payment_session_id) && count($payment_session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_session_id when calling createShipmentTracking'
            );
        }

        // verify the required parameter 'shipment_tracking_create_input' is set
        if ($shipment_tracking_create_input === null || (is_array($shipment_tracking_create_input) && count($shipment_tracking_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_tracking_create_input when calling createShipmentTracking'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/payment-sessions/{paymentSessionId}/shipment-tracking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($payment_session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentSessionId' . '}',
                ObjectSerializer::toPathValue($payment_session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($shipment_tracking_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($shipment_tracking_create_input));
            } else {
                $httpBody = $shipment_tracking_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShipmentTrackingWithCheckout
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTrackingWithCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ShipmentTracking
     */
    public function createShipmentTrackingWithCheckout($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTrackingWithCheckout'][0])
    {
        list($response) = $this->createShipmentTrackingWithCheckoutWithHttpInfo($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createShipmentTrackingWithCheckoutWithHttpInfo
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTrackingWithCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ShipmentTracking, HTTP status code, HTTP response headers (array of strings)
     */
    public function createShipmentTrackingWithCheckoutWithHttpInfo($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTrackingWithCheckout'][0])
    {
        $request = $this->createShipmentTrackingWithCheckoutRequest($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ShipmentTracking' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ShipmentTracking' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ShipmentTracking', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ShipmentTracking';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ShipmentTracking',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createShipmentTrackingWithCheckoutAsync
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTrackingWithCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentTrackingWithCheckoutAsync($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTrackingWithCheckout'][0])
    {
        return $this->createShipmentTrackingWithCheckoutAsyncWithHttpInfo($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShipmentTrackingWithCheckoutAsyncWithHttpInfo
     *
     * Create a shipment tracking entry for a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTrackingWithCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentTrackingWithCheckoutAsyncWithHttpInfo($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTrackingWithCheckout'][0])
    {
        $returnType = '\Rvvup\Api\Model\ShipmentTracking';
        $request = $this->createShipmentTrackingWithCheckoutRequest($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShipmentTrackingWithCheckout'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  \Rvvup\Api\Model\ShipmentTrackingCreateInput $shipment_tracking_create_input Input for adding new shipment tracking (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createShipmentTrackingWithCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createShipmentTrackingWithCheckoutRequest($merchant_id, $payment_session_id, $checkout_id, $shipment_tracking_create_input, string $contentType = self::contentTypes['createShipmentTrackingWithCheckout'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createShipmentTrackingWithCheckout'
            );
        }

        // verify the required parameter 'payment_session_id' is set
        if ($payment_session_id === null || (is_array($payment_session_id) && count($payment_session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_session_id when calling createShipmentTrackingWithCheckout'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling createShipmentTrackingWithCheckout'
            );
        }

        // verify the required parameter 'shipment_tracking_create_input' is set
        if ($shipment_tracking_create_input === null || (is_array($shipment_tracking_create_input) && count($shipment_tracking_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_tracking_create_input when calling createShipmentTrackingWithCheckout'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}/payment-sessions/{paymentSessionId}/shipment-tracking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($payment_session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentSessionId' . '}',
                ObjectSerializer::toPathValue($payment_session_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($shipment_tracking_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($shipment_tracking_create_input));
            } else {
                $httpBody = $shipment_tracking_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTheme
     *
     * Create a new theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ThemeCreateInput $theme_create_input The theme to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheme'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Theme
     */
    public function createTheme($merchant_id, $theme_create_input, string $contentType = self::contentTypes['createTheme'][0])
    {
        list($response) = $this->createThemeWithHttpInfo($merchant_id, $theme_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createThemeWithHttpInfo
     *
     * Create a new theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ThemeCreateInput $theme_create_input The theme to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheme'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Theme, HTTP status code, HTTP response headers (array of strings)
     */
    public function createThemeWithHttpInfo($merchant_id, $theme_create_input, string $contentType = self::contentTypes['createTheme'][0])
    {
        $request = $this->createThemeRequest($merchant_id, $theme_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Theme' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Theme' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Theme', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Theme';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Theme',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createThemeAsync
     *
     * Create a new theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ThemeCreateInput $theme_create_input The theme to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createThemeAsync($merchant_id, $theme_create_input, string $contentType = self::contentTypes['createTheme'][0])
    {
        return $this->createThemeAsyncWithHttpInfo($merchant_id, $theme_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createThemeAsyncWithHttpInfo
     *
     * Create a new theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ThemeCreateInput $theme_create_input The theme to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createThemeAsyncWithHttpInfo($merchant_id, $theme_create_input, string $contentType = self::contentTypes['createTheme'][0])
    {
        $returnType = '\Rvvup\Api\Model\Theme';
        $request = $this->createThemeRequest($merchant_id, $theme_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTheme'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\ThemeCreateInput $theme_create_input The theme to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createThemeRequest($merchant_id, $theme_create_input, string $contentType = self::contentTypes['createTheme'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createTheme'
            );
        }

        // verify the required parameter 'theme_create_input' is set
        if ($theme_create_input === null || (is_array($theme_create_input) && count($theme_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $theme_create_input when calling createTheme'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/themes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($theme_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($theme_create_input));
            } else {
                $httpBody = $theme_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWebhook
     *
     * Create a new webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\WebhookCreateInput $webhook_create_input The webhook to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Webhook
     */
    public function createWebhook($merchant_id, $webhook_create_input, string $contentType = self::contentTypes['createWebhook'][0])
    {
        list($response) = $this->createWebhookWithHttpInfo($merchant_id, $webhook_create_input, $contentType);
        return $response;
    }

    /**
     * Operation createWebhookWithHttpInfo
     *
     * Create a new webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\WebhookCreateInput $webhook_create_input The webhook to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWebhookWithHttpInfo($merchant_id, $webhook_create_input, string $contentType = self::contentTypes['createWebhook'][0])
    {
        $request = $this->createWebhookRequest($merchant_id, $webhook_create_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createWebhookAsync
     *
     * Create a new webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\WebhookCreateInput $webhook_create_input The webhook to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookAsync($merchant_id, $webhook_create_input, string $contentType = self::contentTypes['createWebhook'][0])
    {
        return $this->createWebhookAsyncWithHttpInfo($merchant_id, $webhook_create_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWebhookAsyncWithHttpInfo
     *
     * Create a new webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\WebhookCreateInput $webhook_create_input The webhook to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookAsyncWithHttpInfo($merchant_id, $webhook_create_input, string $contentType = self::contentTypes['createWebhook'][0])
    {
        $returnType = '\Rvvup\Api\Model\Webhook';
        $request = $this->createWebhookRequest($merchant_id, $webhook_create_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWebhook'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  \Rvvup\Api\Model\WebhookCreateInput $webhook_create_input The webhook to create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWebhookRequest($merchant_id, $webhook_create_input, string $contentType = self::contentTypes['createWebhook'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling createWebhook'
            );
        }

        // verify the required parameter 'webhook_create_input' is set
        if ($webhook_create_input === null || (is_array($webhook_create_input) && count($webhook_create_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_create_input when calling createWebhook'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_create_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_create_input));
            } else {
                $httpBody = $webhook_create_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deactivatePaymentLink
     *
     * Deactivate a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivatePaymentLink'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentLink
     */
    public function deactivatePaymentLink($payment_link_id, $merchant_id, string $contentType = self::contentTypes['deactivatePaymentLink'][0])
    {
        list($response) = $this->deactivatePaymentLinkWithHttpInfo($payment_link_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation deactivatePaymentLinkWithHttpInfo
     *
     * Deactivate a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivatePaymentLink'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function deactivatePaymentLinkWithHttpInfo($payment_link_id, $merchant_id, string $contentType = self::contentTypes['deactivatePaymentLink'][0])
    {
        $request = $this->deactivatePaymentLinkRequest($payment_link_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deactivatePaymentLinkAsync
     *
     * Deactivate a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivatePaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deactivatePaymentLinkAsync($payment_link_id, $merchant_id, string $contentType = self::contentTypes['deactivatePaymentLink'][0])
    {
        return $this->deactivatePaymentLinkAsyncWithHttpInfo($payment_link_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deactivatePaymentLinkAsyncWithHttpInfo
     *
     * Deactivate a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivatePaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deactivatePaymentLinkAsyncWithHttpInfo($payment_link_id, $merchant_id, string $contentType = self::contentTypes['deactivatePaymentLink'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentLink';
        $request = $this->deactivatePaymentLinkRequest($payment_link_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deactivatePaymentLink'
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivatePaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deactivatePaymentLinkRequest($payment_link_id, $merchant_id, string $contentType = self::contentTypes['deactivatePaymentLink'][0])
    {

        // verify the required parameter 'payment_link_id' is set
        if ($payment_link_id === null || (is_array($payment_link_id) && count($payment_link_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_link_id when calling deactivatePaymentLink'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling deactivatePaymentLink'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/payment-links/{paymentLinkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentLinkId' . '}',
                ObjectSerializer::toPathValue($payment_link_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCreditNote
     *
     * Delete a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCreditNote($credit_note_id, $merchant_id, string $contentType = self::contentTypes['deleteCreditNote'][0])
    {
        $this->deleteCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $contentType);
    }

    /**
     * Operation deleteCreditNoteWithHttpInfo
     *
     * Delete a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCreditNoteWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['deleteCreditNote'][0])
    {
        $request = $this->deleteCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCreditNoteAsync
     *
     * Delete a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCreditNoteAsync($credit_note_id, $merchant_id, string $contentType = self::contentTypes['deleteCreditNote'][0])
    {
        return $this->deleteCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCreditNoteAsyncWithHttpInfo
     *
     * Delete a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['deleteCreditNote'][0])
    {
        $returnType = '';
        $request = $this->deleteCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCreditNoteRequest($credit_note_id, $merchant_id, string $contentType = self::contentTypes['deleteCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling deleteCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling deleteCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInvoice
     *
     * Delete a draft invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInvoice($merchant_id, $invoice_id, string $contentType = self::contentTypes['deleteInvoice'][0])
    {
        $this->deleteInvoiceWithHttpInfo($merchant_id, $invoice_id, $contentType);
    }

    /**
     * Operation deleteInvoiceWithHttpInfo
     *
     * Delete a draft invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInvoiceWithHttpInfo($merchant_id, $invoice_id, string $contentType = self::contentTypes['deleteInvoice'][0])
    {
        $request = $this->deleteInvoiceRequest($merchant_id, $invoice_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInvoiceAsync
     *
     * Delete a draft invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceAsync($merchant_id, $invoice_id, string $contentType = self::contentTypes['deleteInvoice'][0])
    {
        return $this->deleteInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInvoiceAsyncWithHttpInfo
     *
     * Delete a draft invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, string $contentType = self::contentTypes['deleteInvoice'][0])
    {
        $returnType = '';
        $request = $this->deleteInvoiceRequest($merchant_id, $invoice_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInvoice'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteInvoiceRequest($merchant_id, $invoice_id, string $contentType = self::contentTypes['deleteInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling deleteInvoice'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling deleteInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMerchantDomain
     *
     * Delete a merchant domain
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $merchant_domain_id Merchant Domain ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMerchantDomain'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMerchantDomain($merchant_id, $merchant_domain_id, string $contentType = self::contentTypes['deleteMerchantDomain'][0])
    {
        $this->deleteMerchantDomainWithHttpInfo($merchant_id, $merchant_domain_id, $contentType);
    }

    /**
     * Operation deleteMerchantDomainWithHttpInfo
     *
     * Delete a merchant domain
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $merchant_domain_id Merchant Domain ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMerchantDomain'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMerchantDomainWithHttpInfo($merchant_id, $merchant_domain_id, string $contentType = self::contentTypes['deleteMerchantDomain'][0])
    {
        $request = $this->deleteMerchantDomainRequest($merchant_id, $merchant_domain_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMerchantDomainAsync
     *
     * Delete a merchant domain
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $merchant_domain_id Merchant Domain ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMerchantDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMerchantDomainAsync($merchant_id, $merchant_domain_id, string $contentType = self::contentTypes['deleteMerchantDomain'][0])
    {
        return $this->deleteMerchantDomainAsyncWithHttpInfo($merchant_id, $merchant_domain_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMerchantDomainAsyncWithHttpInfo
     *
     * Delete a merchant domain
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $merchant_domain_id Merchant Domain ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMerchantDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMerchantDomainAsyncWithHttpInfo($merchant_id, $merchant_domain_id, string $contentType = self::contentTypes['deleteMerchantDomain'][0])
    {
        $returnType = '';
        $request = $this->deleteMerchantDomainRequest($merchant_id, $merchant_domain_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMerchantDomain'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $merchant_domain_id Merchant Domain ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMerchantDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMerchantDomainRequest($merchant_id, $merchant_domain_id, string $contentType = self::contentTypes['deleteMerchantDomain'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling deleteMerchantDomain'
            );
        }

        // verify the required parameter 'merchant_domain_id' is set
        if ($merchant_domain_id === null || (is_array($merchant_domain_id) && count($merchant_domain_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_domain_id when calling deleteMerchantDomain'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/domains/{merchantDomainId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_domain_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantDomainId' . '}',
                ObjectSerializer::toPathValue($merchant_domain_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disconnectConnection
     *
     * Disconnect a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disconnectConnection'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Connection
     */
    public function disconnectConnection($merchant_id, $connection_id, string $contentType = self::contentTypes['disconnectConnection'][0])
    {
        list($response) = $this->disconnectConnectionWithHttpInfo($merchant_id, $connection_id, $contentType);
        return $response;
    }

    /**
     * Operation disconnectConnectionWithHttpInfo
     *
     * Disconnect a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disconnectConnection'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Connection, HTTP status code, HTTP response headers (array of strings)
     */
    public function disconnectConnectionWithHttpInfo($merchant_id, $connection_id, string $contentType = self::contentTypes['disconnectConnection'][0])
    {
        $request = $this->disconnectConnectionRequest($merchant_id, $connection_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Connection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Connection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Connection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Connection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Connection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation disconnectConnectionAsync
     *
     * Disconnect a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disconnectConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disconnectConnectionAsync($merchant_id, $connection_id, string $contentType = self::contentTypes['disconnectConnection'][0])
    {
        return $this->disconnectConnectionAsyncWithHttpInfo($merchant_id, $connection_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disconnectConnectionAsyncWithHttpInfo
     *
     * Disconnect a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disconnectConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disconnectConnectionAsyncWithHttpInfo($merchant_id, $connection_id, string $contentType = self::contentTypes['disconnectConnection'][0])
    {
        $returnType = '\Rvvup\Api\Model\Connection';
        $request = $this->disconnectConnectionRequest($merchant_id, $connection_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disconnectConnection'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disconnectConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disconnectConnectionRequest($merchant_id, $connection_id, string $contentType = self::contentTypes['disconnectConnection'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling disconnectConnection'
            );
        }

        // verify the required parameter 'connection_id' is set
        if ($connection_id === null || (is_array($connection_id) && count($connection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_id when calling disconnectConnection'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/connections/{connectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($connection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'connectionId' . '}',
                ObjectSerializer::toPathValue($connection_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadCreditNote
     *
     * Get a link to download the credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNoteDownload
     */
    public function downloadCreditNote($credit_note_id, $merchant_id, string $contentType = self::contentTypes['downloadCreditNote'][0])
    {
        list($response) = $this->downloadCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation downloadCreditNoteWithHttpInfo
     *
     * Get a link to download the credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNoteDownload, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadCreditNoteWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['downloadCreditNote'][0])
    {
        $request = $this->downloadCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNoteDownload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNoteDownload' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNoteDownload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNoteDownload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNoteDownload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadCreditNoteAsync
     *
     * Get a link to download the credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadCreditNoteAsync($credit_note_id, $merchant_id, string $contentType = self::contentTypes['downloadCreditNote'][0])
    {
        return $this->downloadCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadCreditNoteAsyncWithHttpInfo
     *
     * Get a link to download the credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['downloadCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNoteDownload';
        $request = $this->downloadCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadCreditNoteRequest($credit_note_id, $merchant_id, string $contentType = self::contentTypes['downloadCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling downloadCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling downloadCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadCreditNoteForInvoice
     *
     * Get a link to download the credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $credit_note_id credit note id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNoteForInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNoteDownload
     */
    public function downloadCreditNoteForInvoice($merchant_id, $invoice_id, $credit_note_id, string $contentType = self::contentTypes['downloadCreditNoteForInvoice'][0])
    {
        list($response) = $this->downloadCreditNoteForInvoiceWithHttpInfo($merchant_id, $invoice_id, $credit_note_id, $contentType);
        return $response;
    }

    /**
     * Operation downloadCreditNoteForInvoiceWithHttpInfo
     *
     * Get a link to download the credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $credit_note_id credit note id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNoteForInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNoteDownload, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadCreditNoteForInvoiceWithHttpInfo($merchant_id, $invoice_id, $credit_note_id, string $contentType = self::contentTypes['downloadCreditNoteForInvoice'][0])
    {
        $request = $this->downloadCreditNoteForInvoiceRequest($merchant_id, $invoice_id, $credit_note_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNoteDownload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNoteDownload' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNoteDownload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNoteDownload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNoteDownload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadCreditNoteForInvoiceAsync
     *
     * Get a link to download the credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $credit_note_id credit note id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNoteForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadCreditNoteForInvoiceAsync($merchant_id, $invoice_id, $credit_note_id, string $contentType = self::contentTypes['downloadCreditNoteForInvoice'][0])
    {
        return $this->downloadCreditNoteForInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $credit_note_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadCreditNoteForInvoiceAsyncWithHttpInfo
     *
     * Get a link to download the credit note
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $credit_note_id credit note id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNoteForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadCreditNoteForInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $credit_note_id, string $contentType = self::contentTypes['downloadCreditNoteForInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNoteDownload';
        $request = $this->downloadCreditNoteForInvoiceRequest($merchant_id, $invoice_id, $credit_note_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadCreditNoteForInvoice'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  string $credit_note_id credit note id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadCreditNoteForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadCreditNoteForInvoiceRequest($merchant_id, $invoice_id, $credit_note_id, string $contentType = self::contentTypes['downloadCreditNoteForInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling downloadCreditNoteForInvoice'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling downloadCreditNoteForInvoice'
            );
        }

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling downloadCreditNoteForInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/credit-notes/{creditNoteId}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadInvoice
     *
     * Get a link to download the invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\InvoiceDownload
     */
    public function downloadInvoice($merchant_id, $invoice_id, string $contentType = self::contentTypes['downloadInvoice'][0])
    {
        list($response) = $this->downloadInvoiceWithHttpInfo($merchant_id, $invoice_id, $contentType);
        return $response;
    }

    /**
     * Operation downloadInvoiceWithHttpInfo
     *
     * Get a link to download the invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\InvoiceDownload, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadInvoiceWithHttpInfo($merchant_id, $invoice_id, string $contentType = self::contentTypes['downloadInvoice'][0])
    {
        $request = $this->downloadInvoiceRequest($merchant_id, $invoice_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\InvoiceDownload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\InvoiceDownload' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\InvoiceDownload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\InvoiceDownload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\InvoiceDownload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadInvoiceAsync
     *
     * Get a link to download the invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadInvoiceAsync($merchant_id, $invoice_id, string $contentType = self::contentTypes['downloadInvoice'][0])
    {
        return $this->downloadInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadInvoiceAsyncWithHttpInfo
     *
     * Get a link to download the invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, string $contentType = self::contentTypes['downloadInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\InvoiceDownload';
        $request = $this->downloadInvoiceRequest($merchant_id, $invoice_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadInvoice'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadInvoiceRequest($merchant_id, $invoice_id, string $contentType = self::contentTypes['downloadInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling downloadInvoice'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling downloadInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportStatement
     *
     * Export a statement
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\StatementExportRequest $statement_export_request Statement export filters (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function exportStatement($merchant_id, $statement_export_request, string $contentType = self::contentTypes['exportStatement'][0])
    {
        $this->exportStatementWithHttpInfo($merchant_id, $statement_export_request, $contentType);
    }

    /**
     * Operation exportStatementWithHttpInfo
     *
     * Export a statement
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\StatementExportRequest $statement_export_request Statement export filters (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportStatementWithHttpInfo($merchant_id, $statement_export_request, string $contentType = self::contentTypes['exportStatement'][0])
    {
        $request = $this->exportStatementRequest($merchant_id, $statement_export_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation exportStatementAsync
     *
     * Export a statement
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\StatementExportRequest $statement_export_request Statement export filters (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportStatementAsync($merchant_id, $statement_export_request, string $contentType = self::contentTypes['exportStatement'][0])
    {
        return $this->exportStatementAsyncWithHttpInfo($merchant_id, $statement_export_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportStatementAsyncWithHttpInfo
     *
     * Export a statement
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\StatementExportRequest $statement_export_request Statement export filters (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportStatementAsyncWithHttpInfo($merchant_id, $statement_export_request, string $contentType = self::contentTypes['exportStatement'][0])
    {
        $returnType = '';
        $request = $this->exportStatementRequest($merchant_id, $statement_export_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportStatement'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\StatementExportRequest $statement_export_request Statement export filters (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['exportStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function exportStatementRequest($merchant_id, $statement_export_request, string $contentType = self::contentTypes['exportStatement'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling exportStatement'
            );
        }

        // verify the required parameter 'statement_export_request' is set
        if ($statement_export_request === null || (is_array($statement_export_request) && count($statement_export_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $statement_export_request when calling exportStatement'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/statements/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($statement_export_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($statement_export_request));
            } else {
                $httpBody = $statement_export_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation finalizeCreditNote
     *
     * Finalize a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNote
     */
    public function finalizeCreditNote($credit_note_id, $merchant_id, string $contentType = self::contentTypes['finalizeCreditNote'][0])
    {
        list($response) = $this->finalizeCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation finalizeCreditNoteWithHttpInfo
     *
     * Finalize a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function finalizeCreditNoteWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['finalizeCreditNote'][0])
    {
        $request = $this->finalizeCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNote' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation finalizeCreditNoteAsync
     *
     * Finalize a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeCreditNoteAsync($credit_note_id, $merchant_id, string $contentType = self::contentTypes['finalizeCreditNote'][0])
    {
        return $this->finalizeCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation finalizeCreditNoteAsyncWithHttpInfo
     *
     * Finalize a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['finalizeCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNote';
        $request = $this->finalizeCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'finalizeCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function finalizeCreditNoteRequest($credit_note_id, $merchant_id, string $contentType = self::contentTypes['finalizeCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling finalizeCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling finalizeCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}/finalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation finalizeInvoice
     *
     * Finalize an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Invoice
     */
    public function finalizeInvoice($invoice_id, $merchant_id, string $contentType = self::contentTypes['finalizeInvoice'][0])
    {
        list($response) = $this->finalizeInvoiceWithHttpInfo($invoice_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation finalizeInvoiceWithHttpInfo
     *
     * Finalize an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function finalizeInvoiceWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['finalizeInvoice'][0])
    {
        $request = $this->finalizeInvoiceRequest($invoice_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Invoice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Invoice' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Invoice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Invoice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation finalizeInvoiceAsync
     *
     * Finalize an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeInvoiceAsync($invoice_id, $merchant_id, string $contentType = self::contentTypes['finalizeInvoice'][0])
    {
        return $this->finalizeInvoiceAsyncWithHttpInfo($invoice_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation finalizeInvoiceAsyncWithHttpInfo
     *
     * Finalize an invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function finalizeInvoiceAsyncWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['finalizeInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\Invoice';
        $request = $this->finalizeInvoiceRequest($invoice_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'finalizeInvoice'
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['finalizeInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function finalizeInvoiceRequest($invoice_id, $merchant_id, string $contentType = self::contentTypes['finalizeInvoice'][0])
    {

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling finalizeInvoice'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling finalizeInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/finalize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountStatement
     *
     * Get an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\AccountStatement
     */
    public function getAccountStatement($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getAccountStatement'][0])
    {
        list($response) = $this->getAccountStatementWithHttpInfo($merchant_id, $account_statement_id, $contentType);
        return $response;
    }

    /**
     * Operation getAccountStatementWithHttpInfo
     *
     * Get an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\AccountStatement, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountStatementWithHttpInfo($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getAccountStatement'][0])
    {
        $request = $this->getAccountStatementRequest($merchant_id, $account_statement_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\AccountStatement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\AccountStatement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\AccountStatement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\AccountStatement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\AccountStatement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountStatementAsync
     *
     * Get an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountStatementAsync($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getAccountStatement'][0])
    {
        return $this->getAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountStatementAsyncWithHttpInfo
     *
     * Get an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getAccountStatement'][0])
    {
        $returnType = '\Rvvup\Api\Model\AccountStatement';
        $request = $this->getAccountStatementRequest($merchant_id, $account_statement_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountStatement'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAccountStatementRequest($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getAccountStatement'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getAccountStatement'
            );
        }

        // verify the required parameter 'account_statement_id' is set
        if ($account_statement_id === null || (is_array($account_statement_id) && count($account_statement_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_statement_id when calling getAccountStatement'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/accounts/statements/{accountStatementId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($account_statement_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountStatementId' . '}',
                ObjectSerializer::toPathValue($account_statement_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChaserPlan
     *
     * Get a chaser plan
     *
     * @param  string $chaser_plan_id chaser plan id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChaserPlan'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ChaserPlan
     */
    public function getChaserPlan($chaser_plan_id, $merchant_id, string $contentType = self::contentTypes['getChaserPlan'][0])
    {
        list($response) = $this->getChaserPlanWithHttpInfo($chaser_plan_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation getChaserPlanWithHttpInfo
     *
     * Get a chaser plan
     *
     * @param  string $chaser_plan_id chaser plan id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChaserPlan'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ChaserPlan, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChaserPlanWithHttpInfo($chaser_plan_id, $merchant_id, string $contentType = self::contentTypes['getChaserPlan'][0])
    {
        $request = $this->getChaserPlanRequest($chaser_plan_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ChaserPlan' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ChaserPlan' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ChaserPlan', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ChaserPlan';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ChaserPlan',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getChaserPlanAsync
     *
     * Get a chaser plan
     *
     * @param  string $chaser_plan_id chaser plan id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChaserPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChaserPlanAsync($chaser_plan_id, $merchant_id, string $contentType = self::contentTypes['getChaserPlan'][0])
    {
        return $this->getChaserPlanAsyncWithHttpInfo($chaser_plan_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChaserPlanAsyncWithHttpInfo
     *
     * Get a chaser plan
     *
     * @param  string $chaser_plan_id chaser plan id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChaserPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChaserPlanAsyncWithHttpInfo($chaser_plan_id, $merchant_id, string $contentType = self::contentTypes['getChaserPlan'][0])
    {
        $returnType = '\Rvvup\Api\Model\ChaserPlan';
        $request = $this->getChaserPlanRequest($chaser_plan_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChaserPlan'
     *
     * @param  string $chaser_plan_id chaser plan id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChaserPlan'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChaserPlanRequest($chaser_plan_id, $merchant_id, string $contentType = self::contentTypes['getChaserPlan'][0])
    {

        // verify the required parameter 'chaser_plan_id' is set
        if ($chaser_plan_id === null || (is_array($chaser_plan_id) && count($chaser_plan_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chaser_plan_id when calling getChaserPlan'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getChaserPlan'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/chaser-plans/{chaserPlanId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chaser_plan_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chaserPlanId' . '}',
                ObjectSerializer::toPathValue($chaser_plan_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCheckout
     *
     * Get a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $accept Accept header (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Checkout
     */
    public function getCheckout($checkout_id, $merchant_id, $accept = null, string $contentType = self::contentTypes['getCheckout'][0])
    {
        list($response) = $this->getCheckoutWithHttpInfo($checkout_id, $merchant_id, $accept, $contentType);
        return $response;
    }

    /**
     * Operation getCheckoutWithHttpInfo
     *
     * Get a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $accept Accept header (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Checkout, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCheckoutWithHttpInfo($checkout_id, $merchant_id, $accept = null, string $contentType = self::contentTypes['getCheckout'][0])
    {
        $request = $this->getCheckoutRequest($checkout_id, $merchant_id, $accept, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Checkout' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Checkout' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Checkout', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Checkout';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Checkout',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCheckoutAsync
     *
     * Get a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $accept Accept header (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutAsync($checkout_id, $merchant_id, $accept = null, string $contentType = self::contentTypes['getCheckout'][0])
    {
        return $this->getCheckoutAsyncWithHttpInfo($checkout_id, $merchant_id, $accept, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCheckoutAsyncWithHttpInfo
     *
     * Get a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $accept Accept header (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutAsyncWithHttpInfo($checkout_id, $merchant_id, $accept = null, string $contentType = self::contentTypes['getCheckout'][0])
    {
        $returnType = '\Rvvup\Api\Model\Checkout';
        $request = $this->getCheckoutRequest($checkout_id, $merchant_id, $accept, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCheckout'
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $accept Accept header (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCheckoutRequest($checkout_id, $merchant_id, $accept = null, string $contentType = self::contentTypes['getCheckout'][0])
    {

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling getCheckout'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCheckout'
            );
        }



        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/schema+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCheckoutForAccountStatement
     *
     * Get a checkout for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Checkout
     */
    public function getCheckoutForAccountStatement($merchant_id, $account_statement_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForAccountStatement'][0])
    {
        list($response) = $this->getCheckoutForAccountStatementWithHttpInfo($merchant_id, $account_statement_id, $checkout_id, $contentType);
        return $response;
    }

    /**
     * Operation getCheckoutForAccountStatementWithHttpInfo
     *
     * Get a checkout for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Checkout, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCheckoutForAccountStatementWithHttpInfo($merchant_id, $account_statement_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForAccountStatement'][0])
    {
        $request = $this->getCheckoutForAccountStatementRequest($merchant_id, $account_statement_id, $checkout_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Checkout' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Checkout' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Checkout', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Checkout';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Checkout',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCheckoutForAccountStatementAsync
     *
     * Get a checkout for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutForAccountStatementAsync($merchant_id, $account_statement_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForAccountStatement'][0])
    {
        return $this->getCheckoutForAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_id, $checkout_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCheckoutForAccountStatementAsyncWithHttpInfo
     *
     * Get a checkout for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutForAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForAccountStatement'][0])
    {
        $returnType = '\Rvvup\Api\Model\Checkout';
        $request = $this->getCheckoutForAccountStatementRequest($merchant_id, $account_statement_id, $checkout_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCheckoutForAccountStatement'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCheckoutForAccountStatementRequest($merchant_id, $account_statement_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForAccountStatement'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCheckoutForAccountStatement'
            );
        }

        // verify the required parameter 'account_statement_id' is set
        if ($account_statement_id === null || (is_array($account_statement_id) && count($account_statement_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_statement_id when calling getCheckoutForAccountStatement'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling getCheckoutForAccountStatement'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/accounts/statements/{accountStatementId}/checkouts/{checkoutId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($account_statement_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountStatementId' . '}',
                ObjectSerializer::toPathValue($account_statement_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCheckoutForInvoice
     *
     * Get a checkout for an invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Checkout
     */
    public function getCheckoutForInvoice($merchant_id, $invoice_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForInvoice'][0])
    {
        list($response) = $this->getCheckoutForInvoiceWithHttpInfo($merchant_id, $invoice_id, $checkout_id, $contentType);
        return $response;
    }

    /**
     * Operation getCheckoutForInvoiceWithHttpInfo
     *
     * Get a checkout for an invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Checkout, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCheckoutForInvoiceWithHttpInfo($merchant_id, $invoice_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForInvoice'][0])
    {
        $request = $this->getCheckoutForInvoiceRequest($merchant_id, $invoice_id, $checkout_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Checkout' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Checkout' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Checkout', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Checkout';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Checkout',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCheckoutForInvoiceAsync
     *
     * Get a checkout for an invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutForInvoiceAsync($merchant_id, $invoice_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForInvoice'][0])
    {
        return $this->getCheckoutForInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $checkout_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCheckoutForInvoiceAsyncWithHttpInfo
     *
     * Get a checkout for an invoice
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutForInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\Checkout';
        $request = $this->getCheckoutForInvoiceRequest($merchant_id, $invoice_id, $checkout_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCheckoutForInvoice'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $invoice_id Invoice ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCheckoutForInvoiceRequest($merchant_id, $invoice_id, $checkout_id, string $contentType = self::contentTypes['getCheckoutForInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCheckoutForInvoice'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling getCheckoutForInvoice'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling getCheckoutForInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/checkouts/{checkoutId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCheckoutTemplate
     *
     * Get a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CheckoutTemplate
     */
    public function getCheckoutTemplate($checkout_template_id, $merchant_id, string $contentType = self::contentTypes['getCheckoutTemplate'][0])
    {
        list($response) = $this->getCheckoutTemplateWithHttpInfo($checkout_template_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation getCheckoutTemplateWithHttpInfo
     *
     * Get a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CheckoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCheckoutTemplateWithHttpInfo($checkout_template_id, $merchant_id, string $contentType = self::contentTypes['getCheckoutTemplate'][0])
    {
        $request = $this->getCheckoutTemplateRequest($checkout_template_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CheckoutTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CheckoutTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CheckoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CheckoutTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CheckoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCheckoutTemplateAsync
     *
     * Get a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutTemplateAsync($checkout_template_id, $merchant_id, string $contentType = self::contentTypes['getCheckoutTemplate'][0])
    {
        return $this->getCheckoutTemplateAsyncWithHttpInfo($checkout_template_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCheckoutTemplateAsyncWithHttpInfo
     *
     * Get a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCheckoutTemplateAsyncWithHttpInfo($checkout_template_id, $merchant_id, string $contentType = self::contentTypes['getCheckoutTemplate'][0])
    {
        $returnType = '\Rvvup\Api\Model\CheckoutTemplate';
        $request = $this->getCheckoutTemplateRequest($checkout_template_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCheckoutTemplate'
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCheckoutTemplateRequest($checkout_template_id, $merchant_id, string $contentType = self::contentTypes['getCheckoutTemplate'][0])
    {

        // verify the required parameter 'checkout_template_id' is set
        if ($checkout_template_id === null || (is_array($checkout_template_id) && count($checkout_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_template_id when calling getCheckoutTemplate'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCheckoutTemplate'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkout-templates/{checkoutTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($checkout_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutTemplateId' . '}',
                ObjectSerializer::toPathValue($checkout_template_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnection
     *
     * Get a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnection'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Connection
     */
    public function getConnection($merchant_id, $connection_id, string $contentType = self::contentTypes['getConnection'][0])
    {
        list($response) = $this->getConnectionWithHttpInfo($merchant_id, $connection_id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectionWithHttpInfo
     *
     * Get a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnection'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Connection, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectionWithHttpInfo($merchant_id, $connection_id, string $contentType = self::contentTypes['getConnection'][0])
    {
        $request = $this->getConnectionRequest($merchant_id, $connection_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Connection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Connection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Connection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Connection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Connection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectionAsync
     *
     * Get a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectionAsync($merchant_id, $connection_id, string $contentType = self::contentTypes['getConnection'][0])
    {
        return $this->getConnectionAsyncWithHttpInfo($merchant_id, $connection_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectionAsyncWithHttpInfo
     *
     * Get a connection
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectionAsyncWithHttpInfo($merchant_id, $connection_id, string $contentType = self::contentTypes['getConnection'][0])
    {
        $returnType = '\Rvvup\Api\Model\Connection';
        $request = $this->getConnectionRequest($merchant_id, $connection_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnection'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $connection_id Connection ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectionRequest($merchant_id, $connection_id, string $contentType = self::contentTypes['getConnection'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getConnection'
            );
        }

        // verify the required parameter 'connection_id' is set
        if ($connection_id === null || (is_array($connection_id) && count($connection_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connection_id when calling getConnection'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/connections/{connectionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($connection_id !== null) {
            $resourcePath = str_replace(
                '{' . 'connectionId' . '}',
                ObjectSerializer::toPathValue($connection_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCreditNote
     *
     * Get a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNote
     */
    public function getCreditNote($credit_note_id, $merchant_id, string $contentType = self::contentTypes['getCreditNote'][0])
    {
        list($response) = $this->getCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation getCreditNoteWithHttpInfo
     *
     * Get a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCreditNoteWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['getCreditNote'][0])
    {
        $request = $this->getCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNote' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCreditNoteAsync
     *
     * Get a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAsync($credit_note_id, $merchant_id, string $contentType = self::contentTypes['getCreditNote'][0])
    {
        return $this->getCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCreditNoteAsyncWithHttpInfo
     *
     * Get a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['getCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNote';
        $request = $this->getCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCreditNoteRequest($credit_note_id, $merchant_id, string $contentType = self::contentTypes['getCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling getCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerAccount
     *
     * Get a customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccount'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CustomerAccount
     */
    public function getCustomerAccount($customer_account_id, $merchant_id, string $contentType = self::contentTypes['getCustomerAccount'][0])
    {
        list($response) = $this->getCustomerAccountWithHttpInfo($customer_account_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation getCustomerAccountWithHttpInfo
     *
     * Get a customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccount'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CustomerAccount, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerAccountWithHttpInfo($customer_account_id, $merchant_id, string $contentType = self::contentTypes['getCustomerAccount'][0])
    {
        $request = $this->getCustomerAccountRequest($customer_account_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CustomerAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CustomerAccount' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CustomerAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CustomerAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CustomerAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerAccountAsync
     *
     * Get a customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerAccountAsync($customer_account_id, $merchant_id, string $contentType = self::contentTypes['getCustomerAccount'][0])
    {
        return $this->getCustomerAccountAsyncWithHttpInfo($customer_account_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerAccountAsyncWithHttpInfo
     *
     * Get a customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerAccountAsyncWithHttpInfo($customer_account_id, $merchant_id, string $contentType = self::contentTypes['getCustomerAccount'][0])
    {
        $returnType = '\Rvvup\Api\Model\CustomerAccount';
        $request = $this->getCustomerAccountRequest($customer_account_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerAccount'
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCustomerAccountRequest($customer_account_id, $merchant_id, string $contentType = self::contentTypes['getCustomerAccount'][0])
    {

        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null || (is_array($customer_account_id) && count($customer_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_account_id when calling getCustomerAccount'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCustomerAccount'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/customer-accounts/{customerAccountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerAccountId' . '}',
                ObjectSerializer::toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomerAccounts
     *
     * Get customer accounts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccounts'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CustomerAccountPage
     */
    public function getCustomerAccounts($merchant_id, $offset = null, $limit = null, $q = null, string $contentType = self::contentTypes['getCustomerAccounts'][0])
    {
        list($response) = $this->getCustomerAccountsWithHttpInfo($merchant_id, $offset, $limit, $q, $contentType);
        return $response;
    }

    /**
     * Operation getCustomerAccountsWithHttpInfo
     *
     * Get customer accounts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccounts'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CustomerAccountPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomerAccountsWithHttpInfo($merchant_id, $offset = null, $limit = null, $q = null, string $contentType = self::contentTypes['getCustomerAccounts'][0])
    {
        $request = $this->getCustomerAccountsRequest($merchant_id, $offset, $limit, $q, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CustomerAccountPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CustomerAccountPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CustomerAccountPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CustomerAccountPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CustomerAccountPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomerAccountsAsync
     *
     * Get customer accounts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerAccountsAsync($merchant_id, $offset = null, $limit = null, $q = null, string $contentType = self::contentTypes['getCustomerAccounts'][0])
    {
        return $this->getCustomerAccountsAsyncWithHttpInfo($merchant_id, $offset, $limit, $q, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomerAccountsAsyncWithHttpInfo
     *
     * Get customer accounts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomerAccountsAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, $q = null, string $contentType = self::contentTypes['getCustomerAccounts'][0])
    {
        $returnType = '\Rvvup\Api\Model\CustomerAccountPage';
        $request = $this->getCustomerAccountsRequest($merchant_id, $offset, $limit, $q, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomerAccounts'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q search query (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCustomerAccounts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCustomerAccountsRequest($merchant_id, $offset = null, $limit = null, $q = null, string $contentType = self::contentTypes['getCustomerAccounts'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getCustomerAccounts'
            );
        }





        $resourcePath = '/api/2024-03-01/{merchantId}/customer-accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoice
     *
     * Get a invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Invoice
     */
    public function getInvoice($invoice_id, $merchant_id, string $contentType = self::contentTypes['getInvoice'][0])
    {
        list($response) = $this->getInvoiceWithHttpInfo($invoice_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation getInvoiceWithHttpInfo
     *
     * Get a invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['getInvoice'][0])
    {
        $request = $this->getInvoiceRequest($invoice_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Invoice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Invoice' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Invoice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Invoice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceAsync
     *
     * Get a invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsync($invoice_id, $merchant_id, string $contentType = self::contentTypes['getInvoice'][0])
    {
        return $this->getInvoiceAsyncWithHttpInfo($invoice_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceAsyncWithHttpInfo
     *
     * Get a invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceAsyncWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['getInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\Invoice';
        $request = $this->getInvoiceRequest($invoice_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoice'
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInvoiceRequest($invoice_id, $merchant_id, string $contentType = self::contentTypes['getInvoice'][0])
    {

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling getInvoice'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNotificationSubscription
     *
     * Get a notification subscription
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $id Notification Subscription ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\NotificationSubscription
     */
    public function getNotificationSubscription($merchant_id, $id, string $contentType = self::contentTypes['getNotificationSubscription'][0])
    {
        list($response) = $this->getNotificationSubscriptionWithHttpInfo($merchant_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getNotificationSubscriptionWithHttpInfo
     *
     * Get a notification subscription
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $id Notification Subscription ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\NotificationSubscription, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotificationSubscriptionWithHttpInfo($merchant_id, $id, string $contentType = self::contentTypes['getNotificationSubscription'][0])
    {
        $request = $this->getNotificationSubscriptionRequest($merchant_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\NotificationSubscription' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\NotificationSubscription' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\NotificationSubscription', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\NotificationSubscription';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\NotificationSubscription',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNotificationSubscriptionAsync
     *
     * Get a notification subscription
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $id Notification Subscription ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationSubscriptionAsync($merchant_id, $id, string $contentType = self::contentTypes['getNotificationSubscription'][0])
    {
        return $this->getNotificationSubscriptionAsyncWithHttpInfo($merchant_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNotificationSubscriptionAsyncWithHttpInfo
     *
     * Get a notification subscription
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $id Notification Subscription ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotificationSubscriptionAsyncWithHttpInfo($merchant_id, $id, string $contentType = self::contentTypes['getNotificationSubscription'][0])
    {
        $returnType = '\Rvvup\Api\Model\NotificationSubscription';
        $request = $this->getNotificationSubscriptionRequest($merchant_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNotificationSubscription'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $id Notification Subscription ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNotificationSubscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNotificationSubscriptionRequest($merchant_id, $id, string $contentType = self::contentTypes['getNotificationSubscription'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getNotificationSubscription'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNotificationSubscription'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/notification-subscriptions/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderById
     *
     * Get order by ID
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $id order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderById'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Order
     */
    public function getOrderById($merchant_id, $id, string $contentType = self::contentTypes['getOrderById'][0])
    {
        list($response) = $this->getOrderByIdWithHttpInfo($merchant_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation getOrderByIdWithHttpInfo
     *
     * Get order by ID
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $id order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderById'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderByIdWithHttpInfo($merchant_id, $id, string $contentType = self::contentTypes['getOrderById'][0])
    {
        $request = $this->getOrderByIdRequest($merchant_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Order' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrderByIdAsync
     *
     * Get order by ID
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $id order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderByIdAsync($merchant_id, $id, string $contentType = self::contentTypes['getOrderById'][0])
    {
        return $this->getOrderByIdAsyncWithHttpInfo($merchant_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderByIdAsyncWithHttpInfo
     *
     * Get order by ID
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $id order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderByIdAsyncWithHttpInfo($merchant_id, $id, string $contentType = self::contentTypes['getOrderById'][0])
    {
        $returnType = '\Rvvup\Api\Model\Order';
        $request = $this->getOrderByIdRequest($merchant_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderById'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $id order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderByIdRequest($merchant_id, $id, string $contentType = self::contentTypes['getOrderById'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getOrderById'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOrderById'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrders
     *
     * Search orders
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $amount_gte amount greater than or equal to (optional)
     * @param  string $amount_lte amount less than or equal to (optional)
     * @param  string $reference filter by reference (optional)
     * @param  string $currency filter by currency (optional)
     * @param  string $status filter by status (optional)
     * @param  string[] $payment_methods filter by payment methods (optional)
     * @param  string $q search query (optional)
     * @param  string $customer_account_id filter by customer account id (optional)
     * @param  string $created_at_gte created after (inclusive) (optional)
     * @param  string $created_at_lte created before (inclusive) (optional)
     * @param  string $address_name filter by address name (optional)
     * @param  string $address_phone_number filter by address phone number (optional)
     * @param  string $address_company filter by address company (optional)
     * @param  string $address_line1 filter by address line 1 (optional)
     * @param  string $address_line2 filter by address line 2 (optional)
     * @param  string $address_city filter by address city (optional)
     * @param  string $address_state filter by address state (optional)
     * @param  string $address_postcode filter by address postcode (optional)
     * @param  string $address_country_code filter by address country code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\OrdersPage
     */
    public function getOrders($merchant_id, $offset = null, $limit = null, $amount_gte = null, $amount_lte = null, $reference = null, $currency = null, $status = null, $payment_methods = null, $q = null, $customer_account_id = null, $created_at_gte = null, $created_at_lte = null, $address_name = null, $address_phone_number = null, $address_company = null, $address_line1 = null, $address_line2 = null, $address_city = null, $address_state = null, $address_postcode = null, $address_country_code = null, string $contentType = self::contentTypes['getOrders'][0])
    {
        list($response) = $this->getOrdersWithHttpInfo($merchant_id, $offset, $limit, $amount_gte, $amount_lte, $reference, $currency, $status, $payment_methods, $q, $customer_account_id, $created_at_gte, $created_at_lte, $address_name, $address_phone_number, $address_company, $address_line1, $address_line2, $address_city, $address_state, $address_postcode, $address_country_code, $contentType);
        return $response;
    }

    /**
     * Operation getOrdersWithHttpInfo
     *
     * Search orders
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $amount_gte amount greater than or equal to (optional)
     * @param  string $amount_lte amount less than or equal to (optional)
     * @param  string $reference filter by reference (optional)
     * @param  string $currency filter by currency (optional)
     * @param  string $status filter by status (optional)
     * @param  string[] $payment_methods filter by payment methods (optional)
     * @param  string $q search query (optional)
     * @param  string $customer_account_id filter by customer account id (optional)
     * @param  string $created_at_gte created after (inclusive) (optional)
     * @param  string $created_at_lte created before (inclusive) (optional)
     * @param  string $address_name filter by address name (optional)
     * @param  string $address_phone_number filter by address phone number (optional)
     * @param  string $address_company filter by address company (optional)
     * @param  string $address_line1 filter by address line 1 (optional)
     * @param  string $address_line2 filter by address line 2 (optional)
     * @param  string $address_city filter by address city (optional)
     * @param  string $address_state filter by address state (optional)
     * @param  string $address_postcode filter by address postcode (optional)
     * @param  string $address_country_code filter by address country code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\OrdersPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrdersWithHttpInfo($merchant_id, $offset = null, $limit = null, $amount_gte = null, $amount_lte = null, $reference = null, $currency = null, $status = null, $payment_methods = null, $q = null, $customer_account_id = null, $created_at_gte = null, $created_at_lte = null, $address_name = null, $address_phone_number = null, $address_company = null, $address_line1 = null, $address_line2 = null, $address_city = null, $address_state = null, $address_postcode = null, $address_country_code = null, string $contentType = self::contentTypes['getOrders'][0])
    {
        $request = $this->getOrdersRequest($merchant_id, $offset, $limit, $amount_gte, $amount_lte, $reference, $currency, $status, $payment_methods, $q, $customer_account_id, $created_at_gte, $created_at_lte, $address_name, $address_phone_number, $address_company, $address_line1, $address_line2, $address_city, $address_state, $address_postcode, $address_country_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\OrdersPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\OrdersPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\OrdersPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\OrdersPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\OrdersPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrdersAsync
     *
     * Search orders
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $amount_gte amount greater than or equal to (optional)
     * @param  string $amount_lte amount less than or equal to (optional)
     * @param  string $reference filter by reference (optional)
     * @param  string $currency filter by currency (optional)
     * @param  string $status filter by status (optional)
     * @param  string[] $payment_methods filter by payment methods (optional)
     * @param  string $q search query (optional)
     * @param  string $customer_account_id filter by customer account id (optional)
     * @param  string $created_at_gte created after (inclusive) (optional)
     * @param  string $created_at_lte created before (inclusive) (optional)
     * @param  string $address_name filter by address name (optional)
     * @param  string $address_phone_number filter by address phone number (optional)
     * @param  string $address_company filter by address company (optional)
     * @param  string $address_line1 filter by address line 1 (optional)
     * @param  string $address_line2 filter by address line 2 (optional)
     * @param  string $address_city filter by address city (optional)
     * @param  string $address_state filter by address state (optional)
     * @param  string $address_postcode filter by address postcode (optional)
     * @param  string $address_country_code filter by address country code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrdersAsync($merchant_id, $offset = null, $limit = null, $amount_gte = null, $amount_lte = null, $reference = null, $currency = null, $status = null, $payment_methods = null, $q = null, $customer_account_id = null, $created_at_gte = null, $created_at_lte = null, $address_name = null, $address_phone_number = null, $address_company = null, $address_line1 = null, $address_line2 = null, $address_city = null, $address_state = null, $address_postcode = null, $address_country_code = null, string $contentType = self::contentTypes['getOrders'][0])
    {
        return $this->getOrdersAsyncWithHttpInfo($merchant_id, $offset, $limit, $amount_gte, $amount_lte, $reference, $currency, $status, $payment_methods, $q, $customer_account_id, $created_at_gte, $created_at_lte, $address_name, $address_phone_number, $address_company, $address_line1, $address_line2, $address_city, $address_state, $address_postcode, $address_country_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrdersAsyncWithHttpInfo
     *
     * Search orders
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $amount_gte amount greater than or equal to (optional)
     * @param  string $amount_lte amount less than or equal to (optional)
     * @param  string $reference filter by reference (optional)
     * @param  string $currency filter by currency (optional)
     * @param  string $status filter by status (optional)
     * @param  string[] $payment_methods filter by payment methods (optional)
     * @param  string $q search query (optional)
     * @param  string $customer_account_id filter by customer account id (optional)
     * @param  string $created_at_gte created after (inclusive) (optional)
     * @param  string $created_at_lte created before (inclusive) (optional)
     * @param  string $address_name filter by address name (optional)
     * @param  string $address_phone_number filter by address phone number (optional)
     * @param  string $address_company filter by address company (optional)
     * @param  string $address_line1 filter by address line 1 (optional)
     * @param  string $address_line2 filter by address line 2 (optional)
     * @param  string $address_city filter by address city (optional)
     * @param  string $address_state filter by address state (optional)
     * @param  string $address_postcode filter by address postcode (optional)
     * @param  string $address_country_code filter by address country code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrdersAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, $amount_gte = null, $amount_lte = null, $reference = null, $currency = null, $status = null, $payment_methods = null, $q = null, $customer_account_id = null, $created_at_gte = null, $created_at_lte = null, $address_name = null, $address_phone_number = null, $address_company = null, $address_line1 = null, $address_line2 = null, $address_city = null, $address_state = null, $address_postcode = null, $address_country_code = null, string $contentType = self::contentTypes['getOrders'][0])
    {
        $returnType = '\Rvvup\Api\Model\OrdersPage';
        $request = $this->getOrdersRequest($merchant_id, $offset, $limit, $amount_gte, $amount_lte, $reference, $currency, $status, $payment_methods, $q, $customer_account_id, $created_at_gte, $created_at_lte, $address_name, $address_phone_number, $address_company, $address_line1, $address_line2, $address_city, $address_state, $address_postcode, $address_country_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrders'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $amount_gte amount greater than or equal to (optional)
     * @param  string $amount_lte amount less than or equal to (optional)
     * @param  string $reference filter by reference (optional)
     * @param  string $currency filter by currency (optional)
     * @param  string $status filter by status (optional)
     * @param  string[] $payment_methods filter by payment methods (optional)
     * @param  string $q search query (optional)
     * @param  string $customer_account_id filter by customer account id (optional)
     * @param  string $created_at_gte created after (inclusive) (optional)
     * @param  string $created_at_lte created before (inclusive) (optional)
     * @param  string $address_name filter by address name (optional)
     * @param  string $address_phone_number filter by address phone number (optional)
     * @param  string $address_company filter by address company (optional)
     * @param  string $address_line1 filter by address line 1 (optional)
     * @param  string $address_line2 filter by address line 2 (optional)
     * @param  string $address_city filter by address city (optional)
     * @param  string $address_state filter by address state (optional)
     * @param  string $address_postcode filter by address postcode (optional)
     * @param  string $address_country_code filter by address country code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrdersRequest($merchant_id, $offset = null, $limit = null, $amount_gte = null, $amount_lte = null, $reference = null, $currency = null, $status = null, $payment_methods = null, $q = null, $customer_account_id = null, $created_at_gte = null, $created_at_lte = null, $address_name = null, $address_phone_number = null, $address_company = null, $address_line1 = null, $address_line2 = null, $address_city = null, $address_state = null, $address_postcode = null, $address_country_code = null, string $contentType = self::contentTypes['getOrders'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getOrders'
            );
        }























        $resourcePath = '/api/2024-03-01/{merchantId}/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount_gte,
            'amountGte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount_lte,
            'amountLte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reference,
            'reference', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_methods,
            'paymentMethods', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $customer_account_id,
            'customerAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_gte,
            'createdAtGte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at_lte,
            'createdAtLte', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_name,
            'addressName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_phone_number,
            'addressPhoneNumber', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_company,
            'addressCompany', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_line1,
            'addressLine1', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_line2,
            'addressLine2', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_city,
            'addressCity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_state,
            'addressState', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_postcode,
            'addressPostcode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_country_code,
            'addressCountryCode', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentLink
     *
     * Get a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentLink'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentLink
     */
    public function getPaymentLink($payment_link_id, $merchant_id, string $contentType = self::contentTypes['getPaymentLink'][0])
    {
        list($response) = $this->getPaymentLinkWithHttpInfo($payment_link_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation getPaymentLinkWithHttpInfo
     *
     * Get a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentLink'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentLinkWithHttpInfo($payment_link_id, $merchant_id, string $contentType = self::contentTypes['getPaymentLink'][0])
    {
        $request = $this->getPaymentLinkRequest($payment_link_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentLink' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentLinkAsync
     *
     * Get a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentLinkAsync($payment_link_id, $merchant_id, string $contentType = self::contentTypes['getPaymentLink'][0])
    {
        return $this->getPaymentLinkAsyncWithHttpInfo($payment_link_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentLinkAsyncWithHttpInfo
     *
     * Get a payment link
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentLinkAsyncWithHttpInfo($payment_link_id, $merchant_id, string $contentType = self::contentTypes['getPaymentLink'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentLink';
        $request = $this->getPaymentLinkRequest($payment_link_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentLink'
     *
     * @param  string $payment_link_id payment link id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentLinkRequest($payment_link_id, $merchant_id, string $contentType = self::contentTypes['getPaymentLink'][0])
    {

        // verify the required parameter 'payment_link_id' is set
        if ($payment_link_id === null || (is_array($payment_link_id) && count($payment_link_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_link_id when calling getPaymentLink'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getPaymentLink'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/payment-links/{paymentLinkId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($payment_link_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentLinkId' . '}',
                ObjectSerializer::toPathValue($payment_link_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentSession
     *
     * Get a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSession'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentSession
     */
    public function getPaymentSession($merchant_id, $checkout_id, $payment_session_id, string $contentType = self::contentTypes['getPaymentSession'][0])
    {
        list($response) = $this->getPaymentSessionWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, $contentType);
        return $response;
    }

    /**
     * Operation getPaymentSessionWithHttpInfo
     *
     * Get a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSession'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentSession, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentSessionWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, string $contentType = self::contentTypes['getPaymentSession'][0])
    {
        $request = $this->getPaymentSessionRequest($merchant_id, $checkout_id, $payment_session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentSession' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentSession' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentSession', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentSession';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentSession',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentSessionAsync
     *
     * Get a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentSessionAsync($merchant_id, $checkout_id, $payment_session_id, string $contentType = self::contentTypes['getPaymentSession'][0])
    {
        return $this->getPaymentSessionAsyncWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentSessionAsyncWithHttpInfo
     *
     * Get a payment session
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentSessionAsyncWithHttpInfo($merchant_id, $checkout_id, $payment_session_id, string $contentType = self::contentTypes['getPaymentSession'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentSession';
        $request = $this->getPaymentSessionRequest($merchant_id, $checkout_id, $payment_session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentSession'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $checkout_id checkout id (required)
     * @param  string $payment_session_id payment session id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentSessionRequest($merchant_id, $checkout_id, $payment_session_id, string $contentType = self::contentTypes['getPaymentSession'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getPaymentSession'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling getPaymentSession'
            );
        }

        // verify the required parameter 'payment_session_id' is set
        if ($payment_session_id === null || (is_array($payment_session_id) && count($payment_session_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_session_id when calling getPaymentSession'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}/payment-sessions/{paymentSessionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }
        // path params
        if ($payment_session_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentSessionId' . '}',
                ObjectSerializer::toPathValue($payment_session_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentSettings
     *
     * Get payment settings for a merchant
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentSettingsContext $payment_settings_context Context in which to fetch the settings (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $mpk merchant public key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentSettings
     */
    public function getPaymentSettings($merchant_id, $payment_settings_context, $offset = null, $limit = null, $mpk = null, string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        list($response) = $this->getPaymentSettingsWithHttpInfo($merchant_id, $payment_settings_context, $offset, $limit, $mpk, $contentType);
        return $response;
    }

    /**
     * Operation getPaymentSettingsWithHttpInfo
     *
     * Get payment settings for a merchant
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentSettingsContext $payment_settings_context Context in which to fetch the settings (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $mpk merchant public key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentSettingsWithHttpInfo($merchant_id, $payment_settings_context, $offset = null, $limit = null, $mpk = null, string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        $request = $this->getPaymentSettingsRequest($merchant_id, $payment_settings_context, $offset, $limit, $mpk, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentSettings' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentSettingsAsync
     *
     * Get payment settings for a merchant
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentSettingsContext $payment_settings_context Context in which to fetch the settings (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $mpk merchant public key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentSettingsAsync($merchant_id, $payment_settings_context, $offset = null, $limit = null, $mpk = null, string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        return $this->getPaymentSettingsAsyncWithHttpInfo($merchant_id, $payment_settings_context, $offset, $limit, $mpk, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentSettingsAsyncWithHttpInfo
     *
     * Get payment settings for a merchant
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentSettingsContext $payment_settings_context Context in which to fetch the settings (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $mpk merchant public key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentSettingsAsyncWithHttpInfo($merchant_id, $payment_settings_context, $offset = null, $limit = null, $mpk = null, string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentSettings';
        $request = $this->getPaymentSettingsRequest($merchant_id, $payment_settings_context, $offset, $limit, $mpk, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentSettings'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\PaymentSettingsContext $payment_settings_context Context in which to fetch the settings (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $mpk merchant public key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentSettingsRequest($merchant_id, $payment_settings_context, $offset = null, $limit = null, $mpk = null, string $contentType = self::contentTypes['getPaymentSettings'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getPaymentSettings'
            );
        }

        // verify the required parameter 'payment_settings_context' is set
        if ($payment_settings_context === null || (is_array($payment_settings_context) && count($payment_settings_context) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_settings_context when calling getPaymentSettings'
            );
        }





        $resourcePath = '/api/2024-03-01/{merchantId}/payment-settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mpk,
            'mpk', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($payment_settings_context)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($payment_settings_context));
            } else {
                $httpBody = $payment_settings_context;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTheme
     *
     * Get a theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $theme_id Theme ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheme'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Theme
     */
    public function getTheme($merchant_id, $theme_id, string $contentType = self::contentTypes['getTheme'][0])
    {
        list($response) = $this->getThemeWithHttpInfo($merchant_id, $theme_id, $contentType);
        return $response;
    }

    /**
     * Operation getThemeWithHttpInfo
     *
     * Get a theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $theme_id Theme ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheme'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Theme, HTTP status code, HTTP response headers (array of strings)
     */
    public function getThemeWithHttpInfo($merchant_id, $theme_id, string $contentType = self::contentTypes['getTheme'][0])
    {
        $request = $this->getThemeRequest($merchant_id, $theme_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Theme' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Theme' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Theme', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Theme';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Theme',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getThemeAsync
     *
     * Get a theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $theme_id Theme ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getThemeAsync($merchant_id, $theme_id, string $contentType = self::contentTypes['getTheme'][0])
    {
        return $this->getThemeAsyncWithHttpInfo($merchant_id, $theme_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getThemeAsyncWithHttpInfo
     *
     * Get a theme
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $theme_id Theme ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getThemeAsyncWithHttpInfo($merchant_id, $theme_id, string $contentType = self::contentTypes['getTheme'][0])
    {
        $returnType = '\Rvvup\Api\Model\Theme';
        $request = $this->getThemeRequest($merchant_id, $theme_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTheme'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $theme_id Theme ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getThemeRequest($merchant_id, $theme_id, string $contentType = self::contentTypes['getTheme'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getTheme'
            );
        }

        // verify the required parameter 'theme_id' is set
        if ($theme_id === null || (is_array($theme_id) && count($theme_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $theme_id when calling getTheme'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/themes/{themeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($theme_id !== null) {
            $resourcePath = str_replace(
                '{' . 'themeId' . '}',
                ObjectSerializer::toPathValue($theme_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getThemeForAccountStatement
     *
     * Get the theme for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Theme
     */
    public function getThemeForAccountStatement($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getThemeForAccountStatement'][0])
    {
        list($response) = $this->getThemeForAccountStatementWithHttpInfo($merchant_id, $account_statement_id, $contentType);
        return $response;
    }

    /**
     * Operation getThemeForAccountStatementWithHttpInfo
     *
     * Get the theme for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForAccountStatement'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Theme, HTTP status code, HTTP response headers (array of strings)
     */
    public function getThemeForAccountStatementWithHttpInfo($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getThemeForAccountStatement'][0])
    {
        $request = $this->getThemeForAccountStatementRequest($merchant_id, $account_statement_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Theme' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Theme' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Theme', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Theme';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Theme',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getThemeForAccountStatementAsync
     *
     * Get the theme for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getThemeForAccountStatementAsync($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getThemeForAccountStatement'][0])
    {
        return $this->getThemeForAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getThemeForAccountStatementAsyncWithHttpInfo
     *
     * Get the theme for an account statement
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getThemeForAccountStatementAsyncWithHttpInfo($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getThemeForAccountStatement'][0])
    {
        $returnType = '\Rvvup\Api\Model\Theme';
        $request = $this->getThemeForAccountStatementRequest($merchant_id, $account_statement_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getThemeForAccountStatement'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $account_statement_id Account Statement ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForAccountStatement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getThemeForAccountStatementRequest($merchant_id, $account_statement_id, string $contentType = self::contentTypes['getThemeForAccountStatement'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getThemeForAccountStatement'
            );
        }

        // verify the required parameter 'account_statement_id' is set
        if ($account_statement_id === null || (is_array($account_statement_id) && count($account_statement_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_statement_id when calling getThemeForAccountStatement'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/accounts/statements/{accountStatementId}/theme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($account_statement_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountStatementId' . '}',
                ObjectSerializer::toPathValue($account_statement_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getThemeForCheckout
     *
     * Get the theme for a checkout
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Theme
     */
    public function getThemeForCheckout($merchant_id, $checkout_id, string $contentType = self::contentTypes['getThemeForCheckout'][0])
    {
        list($response) = $this->getThemeForCheckoutWithHttpInfo($merchant_id, $checkout_id, $contentType);
        return $response;
    }

    /**
     * Operation getThemeForCheckoutWithHttpInfo
     *
     * Get the theme for a checkout
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForCheckout'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Theme, HTTP status code, HTTP response headers (array of strings)
     */
    public function getThemeForCheckoutWithHttpInfo($merchant_id, $checkout_id, string $contentType = self::contentTypes['getThemeForCheckout'][0])
    {
        $request = $this->getThemeForCheckoutRequest($merchant_id, $checkout_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Theme' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Theme' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Theme', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Theme';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Theme',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getThemeForCheckoutAsync
     *
     * Get the theme for a checkout
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getThemeForCheckoutAsync($merchant_id, $checkout_id, string $contentType = self::contentTypes['getThemeForCheckout'][0])
    {
        return $this->getThemeForCheckoutAsyncWithHttpInfo($merchant_id, $checkout_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getThemeForCheckoutAsyncWithHttpInfo
     *
     * Get the theme for a checkout
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getThemeForCheckoutAsyncWithHttpInfo($merchant_id, $checkout_id, string $contentType = self::contentTypes['getThemeForCheckout'][0])
    {
        $returnType = '\Rvvup\Api\Model\Theme';
        $request = $this->getThemeForCheckoutRequest($merchant_id, $checkout_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getThemeForCheckout'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $checkout_id Checkout ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThemeForCheckout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getThemeForCheckoutRequest($merchant_id, $checkout_id, string $contentType = self::contentTypes['getThemeForCheckout'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getThemeForCheckout'
            );
        }

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling getThemeForCheckout'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}/theme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhook
     *
     * Get a webhook by id
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Webhook
     */
    public function getWebhook($merchant_id, $webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        list($response) = $this->getWebhookWithHttpInfo($merchant_id, $webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookWithHttpInfo
     *
     * Get a webhook by id
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookWithHttpInfo($merchant_id, $webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        $request = $this->getWebhookRequest($merchant_id, $webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookAsync
     *
     * Get a webhook by id
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsync($merchant_id, $webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        return $this->getWebhookAsyncWithHttpInfo($merchant_id, $webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookAsyncWithHttpInfo
     *
     * Get a webhook by id
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsyncWithHttpInfo($merchant_id, $webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        $returnType = '\Rvvup\Api\Model\Webhook';
        $request = $this->getWebhookRequest($merchant_id, $webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhook'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookRequest($merchant_id, $webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling getWebhook'
            );
        }

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhook'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listChaserPlans
     *
     * List Chaser Plans
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChaserPlans'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ChaserPlanPage
     */
    public function listChaserPlans($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listChaserPlans'][0])
    {
        list($response) = $this->listChaserPlansWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listChaserPlansWithHttpInfo
     *
     * List Chaser Plans
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChaserPlans'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ChaserPlanPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listChaserPlansWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listChaserPlans'][0])
    {
        $request = $this->listChaserPlansRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ChaserPlanPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ChaserPlanPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ChaserPlanPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ChaserPlanPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ChaserPlanPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listChaserPlansAsync
     *
     * List Chaser Plans
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChaserPlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listChaserPlansAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listChaserPlans'][0])
    {
        return $this->listChaserPlansAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listChaserPlansAsyncWithHttpInfo
     *
     * List Chaser Plans
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChaserPlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listChaserPlansAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listChaserPlans'][0])
    {
        $returnType = '\Rvvup\Api\Model\ChaserPlanPage';
        $request = $this->listChaserPlansRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listChaserPlans'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChaserPlans'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listChaserPlansRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listChaserPlans'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listChaserPlans'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/chaser-plans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCheckoutPaymentMethods
     *
     * Get payment methods for a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutPaymentMethods'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentMethodDetailsPage
     */
    public function listCheckoutPaymentMethods($checkout_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutPaymentMethods'][0])
    {
        list($response) = $this->listCheckoutPaymentMethodsWithHttpInfo($checkout_id, $merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCheckoutPaymentMethodsWithHttpInfo
     *
     * Get payment methods for a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutPaymentMethods'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentMethodDetailsPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCheckoutPaymentMethodsWithHttpInfo($checkout_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutPaymentMethods'][0])
    {
        $request = $this->listCheckoutPaymentMethodsRequest($checkout_id, $merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentMethodDetailsPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentMethodDetailsPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentMethodDetailsPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentMethodDetailsPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentMethodDetailsPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCheckoutPaymentMethodsAsync
     *
     * Get payment methods for a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutPaymentMethods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCheckoutPaymentMethodsAsync($checkout_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutPaymentMethods'][0])
    {
        return $this->listCheckoutPaymentMethodsAsyncWithHttpInfo($checkout_id, $merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCheckoutPaymentMethodsAsyncWithHttpInfo
     *
     * Get payment methods for a checkout
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutPaymentMethods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCheckoutPaymentMethodsAsyncWithHttpInfo($checkout_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutPaymentMethods'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentMethodDetailsPage';
        $request = $this->listCheckoutPaymentMethodsRequest($checkout_id, $merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCheckoutPaymentMethods'
     *
     * @param  string $checkout_id checkout id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutPaymentMethods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCheckoutPaymentMethodsRequest($checkout_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutPaymentMethods'][0])
    {

        // verify the required parameter 'checkout_id' is set
        if ($checkout_id === null || (is_array($checkout_id) && count($checkout_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_id when calling listCheckoutPaymentMethods'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listCheckoutPaymentMethods'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts/{checkoutId}/payment-methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($checkout_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutId' . '}',
                ObjectSerializer::toPathValue($checkout_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCheckoutTemplates
     *
     * List checkout templates
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutTemplates'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CheckoutTemplatePage
     */
    public function listCheckoutTemplates($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutTemplates'][0])
    {
        list($response) = $this->listCheckoutTemplatesWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCheckoutTemplatesWithHttpInfo
     *
     * List checkout templates
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutTemplates'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CheckoutTemplatePage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCheckoutTemplatesWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutTemplates'][0])
    {
        $request = $this->listCheckoutTemplatesRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CheckoutTemplatePage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CheckoutTemplatePage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CheckoutTemplatePage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CheckoutTemplatePage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CheckoutTemplatePage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCheckoutTemplatesAsync
     *
     * List checkout templates
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCheckoutTemplatesAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutTemplates'][0])
    {
        return $this->listCheckoutTemplatesAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCheckoutTemplatesAsyncWithHttpInfo
     *
     * List checkout templates
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCheckoutTemplatesAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutTemplates'][0])
    {
        $returnType = '\Rvvup\Api\Model\CheckoutTemplatePage';
        $request = $this->listCheckoutTemplatesRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCheckoutTemplates'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckoutTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCheckoutTemplatesRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckoutTemplates'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listCheckoutTemplates'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/checkout-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCheckouts
     *
     * List checkouts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckouts'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CheckoutPage
     */
    public function listCheckouts($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckouts'][0])
    {
        list($response) = $this->listCheckoutsWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCheckoutsWithHttpInfo
     *
     * List checkouts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckouts'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CheckoutPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCheckoutsWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckouts'][0])
    {
        $request = $this->listCheckoutsRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CheckoutPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CheckoutPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CheckoutPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CheckoutPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CheckoutPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCheckoutsAsync
     *
     * List checkouts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckouts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCheckoutsAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckouts'][0])
    {
        return $this->listCheckoutsAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCheckoutsAsyncWithHttpInfo
     *
     * List checkouts
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckouts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCheckoutsAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckouts'][0])
    {
        $returnType = '\Rvvup\Api\Model\CheckoutPage';
        $request = $this->listCheckoutsRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCheckouts'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCheckouts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCheckoutsRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCheckouts'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listCheckouts'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/checkouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listConnections
     *
     * List connections
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnections'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ConnectionPage
     */
    public function listConnections($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listConnections'][0])
    {
        list($response) = $this->listConnectionsWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listConnectionsWithHttpInfo
     *
     * List connections
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnections'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ConnectionPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listConnectionsWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listConnections'][0])
    {
        $request = $this->listConnectionsRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ConnectionPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ConnectionPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ConnectionPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ConnectionPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ConnectionPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listConnectionsAsync
     *
     * List connections
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConnectionsAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listConnections'][0])
    {
        return $this->listConnectionsAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listConnectionsAsyncWithHttpInfo
     *
     * List connections
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listConnectionsAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listConnections'][0])
    {
        $returnType = '\Rvvup\Api\Model\ConnectionPage';
        $request = $this->listConnectionsRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listConnections'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listConnectionsRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listConnections'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listConnections'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCreditNotes
     *
     * List credit notes
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $invoice_id Filter credit notes by invoice ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotes'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNotePage
     */
    public function listCreditNotes($merchant_id, $offset = null, $limit = null, $invoice_id = null, string $contentType = self::contentTypes['listCreditNotes'][0])
    {
        list($response) = $this->listCreditNotesWithHttpInfo($merchant_id, $offset, $limit, $invoice_id, $contentType);
        return $response;
    }

    /**
     * Operation listCreditNotesWithHttpInfo
     *
     * List credit notes
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $invoice_id Filter credit notes by invoice ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotes'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNotePage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCreditNotesWithHttpInfo($merchant_id, $offset = null, $limit = null, $invoice_id = null, string $contentType = self::contentTypes['listCreditNotes'][0])
    {
        $request = $this->listCreditNotesRequest($merchant_id, $offset, $limit, $invoice_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNotePage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNotePage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNotePage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNotePage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNotePage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCreditNotesAsync
     *
     * List credit notes
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $invoice_id Filter credit notes by invoice ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreditNotesAsync($merchant_id, $offset = null, $limit = null, $invoice_id = null, string $contentType = self::contentTypes['listCreditNotes'][0])
    {
        return $this->listCreditNotesAsyncWithHttpInfo($merchant_id, $offset, $limit, $invoice_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCreditNotesAsyncWithHttpInfo
     *
     * List credit notes
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $invoice_id Filter credit notes by invoice ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreditNotesAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, $invoice_id = null, string $contentType = self::contentTypes['listCreditNotes'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNotePage';
        $request = $this->listCreditNotesRequest($merchant_id, $offset, $limit, $invoice_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCreditNotes'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $invoice_id Filter credit notes by invoice ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCreditNotesRequest($merchant_id, $offset = null, $limit = null, $invoice_id = null, string $contentType = self::contentTypes['listCreditNotes'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listCreditNotes'
            );
        }





        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_id,
            'invoiceId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCreditNotesForInvoice
     *
     * List credit notes for an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotesForInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNotePage
     */
    public function listCreditNotesForInvoice($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCreditNotesForInvoice'][0])
    {
        list($response) = $this->listCreditNotesForInvoiceWithHttpInfo($merchant_id, $invoice_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listCreditNotesForInvoiceWithHttpInfo
     *
     * List credit notes for an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotesForInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNotePage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCreditNotesForInvoiceWithHttpInfo($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCreditNotesForInvoice'][0])
    {
        $request = $this->listCreditNotesForInvoiceRequest($merchant_id, $invoice_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNotePage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNotePage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNotePage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNotePage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNotePage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCreditNotesForInvoiceAsync
     *
     * List credit notes for an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotesForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreditNotesForInvoiceAsync($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCreditNotesForInvoice'][0])
    {
        return $this->listCreditNotesForInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCreditNotesForInvoiceAsyncWithHttpInfo
     *
     * List credit notes for an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotesForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCreditNotesForInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCreditNotesForInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNotePage';
        $request = $this->listCreditNotesForInvoiceRequest($merchant_id, $invoice_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCreditNotesForInvoice'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listCreditNotesForInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listCreditNotesForInvoiceRequest($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listCreditNotesForInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listCreditNotesForInvoice'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling listCreditNotesForInvoice'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/credit-notes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInvoiceNotifications
     *
     * List invoice notifications
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoiceNotifications'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\InvoiceNotificationPage
     */
    public function listInvoiceNotifications($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoiceNotifications'][0])
    {
        list($response) = $this->listInvoiceNotificationsWithHttpInfo($merchant_id, $invoice_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listInvoiceNotificationsWithHttpInfo
     *
     * List invoice notifications
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoiceNotifications'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\InvoiceNotificationPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInvoiceNotificationsWithHttpInfo($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoiceNotifications'][0])
    {
        $request = $this->listInvoiceNotificationsRequest($merchant_id, $invoice_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\InvoiceNotificationPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\InvoiceNotificationPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\InvoiceNotificationPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\InvoiceNotificationPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\InvoiceNotificationPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listInvoiceNotificationsAsync
     *
     * List invoice notifications
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoiceNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoiceNotificationsAsync($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoiceNotifications'][0])
    {
        return $this->listInvoiceNotificationsAsyncWithHttpInfo($merchant_id, $invoice_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInvoiceNotificationsAsyncWithHttpInfo
     *
     * List invoice notifications
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoiceNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoiceNotificationsAsyncWithHttpInfo($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoiceNotifications'][0])
    {
        $returnType = '\Rvvup\Api\Model\InvoiceNotificationPage';
        $request = $this->listInvoiceNotificationsRequest($merchant_id, $invoice_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInvoiceNotifications'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoiceNotifications'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInvoiceNotificationsRequest($merchant_id, $invoice_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoiceNotifications'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listInvoiceNotifications'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling listInvoiceNotifications'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/notifications';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInvoices
     *
     * List invoices
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q invoice search query (optional)
     * @param  string $customer_account_id filter to a customer account (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoices'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\InvoicePage
     */
    public function listInvoices($merchant_id, $offset = null, $limit = null, $q = null, $customer_account_id = null, string $contentType = self::contentTypes['listInvoices'][0])
    {
        list($response) = $this->listInvoicesWithHttpInfo($merchant_id, $offset, $limit, $q, $customer_account_id, $contentType);
        return $response;
    }

    /**
     * Operation listInvoicesWithHttpInfo
     *
     * List invoices
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q invoice search query (optional)
     * @param  string $customer_account_id filter to a customer account (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoices'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\InvoicePage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInvoicesWithHttpInfo($merchant_id, $offset = null, $limit = null, $q = null, $customer_account_id = null, string $contentType = self::contentTypes['listInvoices'][0])
    {
        $request = $this->listInvoicesRequest($merchant_id, $offset, $limit, $q, $customer_account_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\InvoicePage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\InvoicePage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\InvoicePage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\InvoicePage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\InvoicePage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listInvoicesAsync
     *
     * List invoices
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q invoice search query (optional)
     * @param  string $customer_account_id filter to a customer account (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoicesAsync($merchant_id, $offset = null, $limit = null, $q = null, $customer_account_id = null, string $contentType = self::contentTypes['listInvoices'][0])
    {
        return $this->listInvoicesAsyncWithHttpInfo($merchant_id, $offset, $limit, $q, $customer_account_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInvoicesAsyncWithHttpInfo
     *
     * List invoices
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q invoice search query (optional)
     * @param  string $customer_account_id filter to a customer account (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoicesAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, $q = null, $customer_account_id = null, string $contentType = self::contentTypes['listInvoices'][0])
    {
        $returnType = '\Rvvup\Api\Model\InvoicePage';
        $request = $this->listInvoicesRequest($merchant_id, $offset, $limit, $q, $customer_account_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInvoices'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $q invoice search query (optional)
     * @param  string $customer_account_id filter to a customer account (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInvoicesRequest($merchant_id, $offset = null, $limit = null, $q = null, $customer_account_id = null, string $contentType = self::contentTypes['listInvoices'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listInvoices'
            );
        }






        $resourcePath = '/api/2024-03-01/{merchantId}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $customer_account_id,
            'customerAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInvoicesForCustomerAccount
     *
     * Get list of invoices for customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoicesForCustomerAccount'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\InvoicePage
     */
    public function listInvoicesForCustomerAccount($customer_account_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoicesForCustomerAccount'][0])
    {
        list($response) = $this->listInvoicesForCustomerAccountWithHttpInfo($customer_account_id, $merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listInvoicesForCustomerAccountWithHttpInfo
     *
     * Get list of invoices for customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoicesForCustomerAccount'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\InvoicePage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInvoicesForCustomerAccountWithHttpInfo($customer_account_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoicesForCustomerAccount'][0])
    {
        $request = $this->listInvoicesForCustomerAccountRequest($customer_account_id, $merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\InvoicePage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\InvoicePage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\InvoicePage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\InvoicePage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\InvoicePage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listInvoicesForCustomerAccountAsync
     *
     * Get list of invoices for customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoicesForCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoicesForCustomerAccountAsync($customer_account_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoicesForCustomerAccount'][0])
    {
        return $this->listInvoicesForCustomerAccountAsyncWithHttpInfo($customer_account_id, $merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInvoicesForCustomerAccountAsyncWithHttpInfo
     *
     * Get list of invoices for customer account
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoicesForCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoicesForCustomerAccountAsyncWithHttpInfo($customer_account_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoicesForCustomerAccount'][0])
    {
        $returnType = '\Rvvup\Api\Model\InvoicePage';
        $request = $this->listInvoicesForCustomerAccountRequest($customer_account_id, $merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInvoicesForCustomerAccount'
     *
     * @param  string $customer_account_id customer account id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listInvoicesForCustomerAccount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInvoicesForCustomerAccountRequest($customer_account_id, $merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listInvoicesForCustomerAccount'][0])
    {

        // verify the required parameter 'customer_account_id' is set
        if ($customer_account_id === null || (is_array($customer_account_id) && count($customer_account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer_account_id when calling listInvoicesForCustomerAccount'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listInvoicesForCustomerAccount'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/customer-accounts/{customerAccountId}/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($customer_account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'customerAccountId' . '}',
                ObjectSerializer::toPathValue($customer_account_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMerchantDomains
     *
     * List merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchantDomains'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\MerchantDomainsPage
     */
    public function listMerchantDomains($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listMerchantDomains'][0])
    {
        list($response) = $this->listMerchantDomainsWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listMerchantDomainsWithHttpInfo
     *
     * List merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchantDomains'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\MerchantDomainsPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMerchantDomainsWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listMerchantDomains'][0])
    {
        $request = $this->listMerchantDomainsRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\MerchantDomainsPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\MerchantDomainsPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\MerchantDomainsPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\MerchantDomainsPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\MerchantDomainsPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listMerchantDomainsAsync
     *
     * List merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchantDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMerchantDomainsAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listMerchantDomains'][0])
    {
        return $this->listMerchantDomainsAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMerchantDomainsAsyncWithHttpInfo
     *
     * List merchant domains
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchantDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMerchantDomainsAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listMerchantDomains'][0])
    {
        $returnType = '\Rvvup\Api\Model\MerchantDomainsPage';
        $request = $this->listMerchantDomainsRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMerchantDomains'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMerchantDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMerchantDomainsRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listMerchantDomains'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listMerchantDomains'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listNotificationSubscriptions
     *
     * List notification subscriptions.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNotificationSubscriptions'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\NotificationSubscriptionPage
     */
    public function listNotificationSubscriptions($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listNotificationSubscriptions'][0])
    {
        list($response) = $this->listNotificationSubscriptionsWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listNotificationSubscriptionsWithHttpInfo
     *
     * List notification subscriptions.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNotificationSubscriptions'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\NotificationSubscriptionPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listNotificationSubscriptionsWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listNotificationSubscriptions'][0])
    {
        $request = $this->listNotificationSubscriptionsRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\NotificationSubscriptionPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\NotificationSubscriptionPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\NotificationSubscriptionPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\NotificationSubscriptionPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\NotificationSubscriptionPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listNotificationSubscriptionsAsync
     *
     * List notification subscriptions.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNotificationSubscriptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNotificationSubscriptionsAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listNotificationSubscriptions'][0])
    {
        return $this->listNotificationSubscriptionsAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listNotificationSubscriptionsAsyncWithHttpInfo
     *
     * List notification subscriptions.
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNotificationSubscriptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listNotificationSubscriptionsAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listNotificationSubscriptions'][0])
    {
        $returnType = '\Rvvup\Api\Model\NotificationSubscriptionPage';
        $request = $this->listNotificationSubscriptionsRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listNotificationSubscriptions'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listNotificationSubscriptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listNotificationSubscriptionsRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listNotificationSubscriptions'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listNotificationSubscriptions'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/notification-subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPaymentLinks
     *
     * List payment links
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentLinks'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentLinkPage
     */
    public function listPaymentLinks($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentLinks'][0])
    {
        list($response) = $this->listPaymentLinksWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPaymentLinksWithHttpInfo
     *
     * List payment links
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentLinks'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentLinkPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaymentLinksWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentLinks'][0])
    {
        $request = $this->listPaymentLinksRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentLinkPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentLinkPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentLinkPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentLinkPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentLinkPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaymentLinksAsync
     *
     * List payment links
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentLinksAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentLinks'][0])
    {
        return $this->listPaymentLinksAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaymentLinksAsyncWithHttpInfo
     *
     * List payment links
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentLinksAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentLinks'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentLinkPage';
        $request = $this->listPaymentLinksRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPaymentLinks'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaymentLinksRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentLinks'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listPaymentLinks'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/payment-links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPaymentMethods
     *
     * Get payment methods
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $currency The transaction currency (optional)
     * @param  string $amount The transaction amount (optional)
     * @param  bool $include_inactive Include inactive payment methods (optional)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentMethods'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\PaymentMethodDetailsPage
     */
    public function listPaymentMethods($merchant_id, $currency = null, $amount = null, $include_inactive = null, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentMethods'][0])
    {
        list($response) = $this->listPaymentMethodsWithHttpInfo($merchant_id, $currency, $amount, $include_inactive, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPaymentMethodsWithHttpInfo
     *
     * Get payment methods
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $currency The transaction currency (optional)
     * @param  string $amount The transaction amount (optional)
     * @param  bool $include_inactive Include inactive payment methods (optional)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentMethods'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\PaymentMethodDetailsPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPaymentMethodsWithHttpInfo($merchant_id, $currency = null, $amount = null, $include_inactive = null, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentMethods'][0])
    {
        $request = $this->listPaymentMethodsRequest($merchant_id, $currency, $amount, $include_inactive, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\PaymentMethodDetailsPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\PaymentMethodDetailsPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\PaymentMethodDetailsPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\PaymentMethodDetailsPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\PaymentMethodDetailsPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listPaymentMethodsAsync
     *
     * Get payment methods
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $currency The transaction currency (optional)
     * @param  string $amount The transaction amount (optional)
     * @param  bool $include_inactive Include inactive payment methods (optional)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentMethods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentMethodsAsync($merchant_id, $currency = null, $amount = null, $include_inactive = null, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentMethods'][0])
    {
        return $this->listPaymentMethodsAsyncWithHttpInfo($merchant_id, $currency, $amount, $include_inactive, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPaymentMethodsAsyncWithHttpInfo
     *
     * Get payment methods
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $currency The transaction currency (optional)
     * @param  string $amount The transaction amount (optional)
     * @param  bool $include_inactive Include inactive payment methods (optional)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentMethods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listPaymentMethodsAsyncWithHttpInfo($merchant_id, $currency = null, $amount = null, $include_inactive = null, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentMethods'][0])
    {
        $returnType = '\Rvvup\Api\Model\PaymentMethodDetailsPage';
        $request = $this->listPaymentMethodsRequest($merchant_id, $currency, $amount, $include_inactive, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPaymentMethods'
     *
     * @param  string $merchant_id The merchant id (required)
     * @param  string $currency The transaction currency (optional)
     * @param  string $amount The transaction amount (optional)
     * @param  bool $include_inactive Include inactive payment methods (optional)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPaymentMethods'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPaymentMethodsRequest($merchant_id, $currency = null, $amount = null, $include_inactive = null, $offset = null, $limit = null, string $contentType = self::contentTypes['listPaymentMethods'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listPaymentMethods'
            );
        }







        $resourcePath = '/api/2024-03-01/{merchantId}/payment-methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_inactive,
            'includeInactive', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listThemes
     *
     * List themes
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset Pagination offset (optional)
     * @param  int $limit Pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThemes'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\ThemePage
     */
    public function listThemes($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listThemes'][0])
    {
        list($response) = $this->listThemesWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listThemesWithHttpInfo
     *
     * List themes
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset Pagination offset (optional)
     * @param  int $limit Pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThemes'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\ThemePage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listThemesWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listThemes'][0])
    {
        $request = $this->listThemesRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\ThemePage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\ThemePage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\ThemePage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\ThemePage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\ThemePage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listThemesAsync
     *
     * List themes
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset Pagination offset (optional)
     * @param  int $limit Pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThemes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listThemesAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listThemes'][0])
    {
        return $this->listThemesAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listThemesAsyncWithHttpInfo
     *
     * List themes
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset Pagination offset (optional)
     * @param  int $limit Pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThemes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listThemesAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listThemes'][0])
    {
        $returnType = '\Rvvup\Api\Model\ThemePage';
        $request = $this->listThemesRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listThemes'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset Pagination offset (optional)
     * @param  int $limit Pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThemes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listThemesRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listThemes'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listThemes'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/themes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listWebhooks
     *
     * Get all webhooks
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\WebhookPage
     */
    public function listWebhooks($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        list($response) = $this->listWebhooksWithHttpInfo($merchant_id, $offset, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listWebhooksWithHttpInfo
     *
     * Get all webhooks
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\WebhookPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function listWebhooksWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        $request = $this->listWebhooksRequest($merchant_id, $offset, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\WebhookPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\WebhookPage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\WebhookPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\WebhookPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\WebhookPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listWebhooksAsync
     *
     * Get all webhooks
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebhooksAsync($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        return $this->listWebhooksAsyncWithHttpInfo($merchant_id, $offset, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listWebhooksAsyncWithHttpInfo
     *
     * Get all webhooks
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listWebhooksAsyncWithHttpInfo($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listWebhooks'][0])
    {
        $returnType = '\Rvvup\Api\Model\WebhookPage';
        $request = $this->listWebhooksRequest($merchant_id, $offset, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listWebhooks'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  int $offset pagination offset (optional)
     * @param  int $limit pagination limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listWebhooksRequest($merchant_id, $offset = null, $limit = null, string $contentType = self::contentTypes['listWebhooks'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling listWebhooks'
            );
        }




        $resourcePath = '/api/2024-03-01/{merchantId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refreshInvoiceUrl
     *
     * Refresh an invoice url
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshInvoiceUrl'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Invoice
     */
    public function refreshInvoiceUrl($invoice_id, $merchant_id, string $contentType = self::contentTypes['refreshInvoiceUrl'][0])
    {
        list($response) = $this->refreshInvoiceUrlWithHttpInfo($invoice_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation refreshInvoiceUrlWithHttpInfo
     *
     * Refresh an invoice url
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshInvoiceUrl'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function refreshInvoiceUrlWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['refreshInvoiceUrl'][0])
    {
        $request = $this->refreshInvoiceUrlRequest($invoice_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Invoice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Invoice' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Invoice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Invoice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation refreshInvoiceUrlAsync
     *
     * Refresh an invoice url
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshInvoiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshInvoiceUrlAsync($invoice_id, $merchant_id, string $contentType = self::contentTypes['refreshInvoiceUrl'][0])
    {
        return $this->refreshInvoiceUrlAsyncWithHttpInfo($invoice_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refreshInvoiceUrlAsyncWithHttpInfo
     *
     * Refresh an invoice url
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshInvoiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshInvoiceUrlAsyncWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['refreshInvoiceUrl'][0])
    {
        $returnType = '\Rvvup\Api\Model\Invoice';
        $request = $this->refreshInvoiceUrlRequest($invoice_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refreshInvoiceUrl'
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshInvoiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refreshInvoiceUrlRequest($invoice_id, $merchant_id, string $contentType = self::contentTypes['refreshInvoiceUrl'][0])
    {

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling refreshInvoiceUrl'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling refreshInvoiceUrl'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/refresh-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCheckoutTemplate
     *
     * Update a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateUpdateInput $checkout_template_update_input The checkout template to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CheckoutTemplate
     */
    public function updateCheckoutTemplate($checkout_template_id, $merchant_id, $checkout_template_update_input, string $contentType = self::contentTypes['updateCheckoutTemplate'][0])
    {
        list($response) = $this->updateCheckoutTemplateWithHttpInfo($checkout_template_id, $merchant_id, $checkout_template_update_input, $contentType);
        return $response;
    }

    /**
     * Operation updateCheckoutTemplateWithHttpInfo
     *
     * Update a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateUpdateInput $checkout_template_update_input The checkout template to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CheckoutTemplate, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCheckoutTemplateWithHttpInfo($checkout_template_id, $merchant_id, $checkout_template_update_input, string $contentType = self::contentTypes['updateCheckoutTemplate'][0])
    {
        $request = $this->updateCheckoutTemplateRequest($checkout_template_id, $merchant_id, $checkout_template_update_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CheckoutTemplate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CheckoutTemplate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CheckoutTemplate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CheckoutTemplate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CheckoutTemplate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCheckoutTemplateAsync
     *
     * Update a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateUpdateInput $checkout_template_update_input The checkout template to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCheckoutTemplateAsync($checkout_template_id, $merchant_id, $checkout_template_update_input, string $contentType = self::contentTypes['updateCheckoutTemplate'][0])
    {
        return $this->updateCheckoutTemplateAsyncWithHttpInfo($checkout_template_id, $merchant_id, $checkout_template_update_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCheckoutTemplateAsyncWithHttpInfo
     *
     * Update a checkout template
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateUpdateInput $checkout_template_update_input The checkout template to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCheckoutTemplateAsyncWithHttpInfo($checkout_template_id, $merchant_id, $checkout_template_update_input, string $contentType = self::contentTypes['updateCheckoutTemplate'][0])
    {
        $returnType = '\Rvvup\Api\Model\CheckoutTemplate';
        $request = $this->updateCheckoutTemplateRequest($checkout_template_id, $merchant_id, $checkout_template_update_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCheckoutTemplate'
     *
     * @param  string $checkout_template_id checkout template id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CheckoutTemplateUpdateInput $checkout_template_update_input The checkout template to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCheckoutTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCheckoutTemplateRequest($checkout_template_id, $merchant_id, $checkout_template_update_input, string $contentType = self::contentTypes['updateCheckoutTemplate'][0])
    {

        // verify the required parameter 'checkout_template_id' is set
        if ($checkout_template_id === null || (is_array($checkout_template_id) && count($checkout_template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_template_id when calling updateCheckoutTemplate'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling updateCheckoutTemplate'
            );
        }

        // verify the required parameter 'checkout_template_update_input' is set
        if ($checkout_template_update_input === null || (is_array($checkout_template_update_input) && count($checkout_template_update_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $checkout_template_update_input when calling updateCheckoutTemplate'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/checkout-templates/{checkoutTemplateId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($checkout_template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'checkoutTemplateId' . '}',
                ObjectSerializer::toPathValue($checkout_template_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($checkout_template_update_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($checkout_template_update_input));
            } else {
                $httpBody = $checkout_template_update_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCreditNote
     *
     * Update a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteUpdateInput $credit_note_update_input The credit note update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNote
     */
    public function updateCreditNote($credit_note_id, $merchant_id, $credit_note_update_input, string $contentType = self::contentTypes['updateCreditNote'][0])
    {
        list($response) = $this->updateCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $credit_note_update_input, $contentType);
        return $response;
    }

    /**
     * Operation updateCreditNoteWithHttpInfo
     *
     * Update a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteUpdateInput $credit_note_update_input The credit note update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $credit_note_update_input, string $contentType = self::contentTypes['updateCreditNote'][0])
    {
        $request = $this->updateCreditNoteRequest($credit_note_id, $merchant_id, $credit_note_update_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNote' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCreditNoteAsync
     *
     * Update a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteUpdateInput $credit_note_update_input The credit note update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCreditNoteAsync($credit_note_id, $merchant_id, $credit_note_update_input, string $contentType = self::contentTypes['updateCreditNote'][0])
    {
        return $this->updateCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $credit_note_update_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCreditNoteAsyncWithHttpInfo
     *
     * Update a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteUpdateInput $credit_note_update_input The credit note update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $credit_note_update_input, string $contentType = self::contentTypes['updateCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNote';
        $request = $this->updateCreditNoteRequest($credit_note_id, $merchant_id, $credit_note_update_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  \Rvvup\Api\Model\CreditNoteUpdateInput $credit_note_update_input The credit note update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateCreditNoteRequest($credit_note_id, $merchant_id, $credit_note_update_input, string $contentType = self::contentTypes['updateCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling updateCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling updateCreditNote'
            );
        }

        // verify the required parameter 'credit_note_update_input' is set
        if ($credit_note_update_input === null || (is_array($credit_note_update_input) && count($credit_note_update_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_update_input when calling updateCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($credit_note_update_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($credit_note_update_input));
            } else {
                $httpBody = $credit_note_update_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInvoice
     *
     * Update an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  \Rvvup\Api\Model\InvoiceUpdateInputDto $invoice_update_input_dto The invoice update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Invoice
     */
    public function updateInvoice($merchant_id, $invoice_id, $invoice_update_input_dto, string $contentType = self::contentTypes['updateInvoice'][0])
    {
        list($response) = $this->updateInvoiceWithHttpInfo($merchant_id, $invoice_id, $invoice_update_input_dto, $contentType);
        return $response;
    }

    /**
     * Operation updateInvoiceWithHttpInfo
     *
     * Update an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  \Rvvup\Api\Model\InvoiceUpdateInputDto $invoice_update_input_dto The invoice update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvoiceWithHttpInfo($merchant_id, $invoice_id, $invoice_update_input_dto, string $contentType = self::contentTypes['updateInvoice'][0])
    {
        $request = $this->updateInvoiceRequest($merchant_id, $invoice_id, $invoice_update_input_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Invoice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Invoice' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Invoice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Invoice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateInvoiceAsync
     *
     * Update an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  \Rvvup\Api\Model\InvoiceUpdateInputDto $invoice_update_input_dto The invoice update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoiceAsync($merchant_id, $invoice_id, $invoice_update_input_dto, string $contentType = self::contentTypes['updateInvoice'][0])
    {
        return $this->updateInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $invoice_update_input_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInvoiceAsyncWithHttpInfo
     *
     * Update an invoice
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  \Rvvup\Api\Model\InvoiceUpdateInputDto $invoice_update_input_dto The invoice update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoiceAsyncWithHttpInfo($merchant_id, $invoice_id, $invoice_update_input_dto, string $contentType = self::contentTypes['updateInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\Invoice';
        $request = $this->updateInvoiceRequest($merchant_id, $invoice_id, $invoice_update_input_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInvoice'
     *
     * @param  string $merchant_id merchant id (required)
     * @param  string $invoice_id invoice id (required)
     * @param  \Rvvup\Api\Model\InvoiceUpdateInputDto $invoice_update_input_dto The invoice update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateInvoiceRequest($merchant_id, $invoice_id, $invoice_update_input_dto, string $contentType = self::contentTypes['updateInvoice'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling updateInvoice'
            );
        }

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling updateInvoice'
            );
        }

        // verify the required parameter 'invoice_update_input_dto' is set
        if ($invoice_update_input_dto === null || (is_array($invoice_update_input_dto) && count($invoice_update_input_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_update_input_dto when calling updateInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($invoice_update_input_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($invoice_update_input_dto));
            } else {
                $httpBody = $invoice_update_input_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTheme
     *
     * Update a theme
     *
     * @param  string $merchant_id merchant ID (required)
     * @param  string $theme_id theme ID (required)
     * @param  \Rvvup\Api\Model\ThemeUpdateInput $theme_update_input The updated theme (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheme'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Theme
     */
    public function updateTheme($merchant_id, $theme_id, $theme_update_input, string $contentType = self::contentTypes['updateTheme'][0])
    {
        list($response) = $this->updateThemeWithHttpInfo($merchant_id, $theme_id, $theme_update_input, $contentType);
        return $response;
    }

    /**
     * Operation updateThemeWithHttpInfo
     *
     * Update a theme
     *
     * @param  string $merchant_id merchant ID (required)
     * @param  string $theme_id theme ID (required)
     * @param  \Rvvup\Api\Model\ThemeUpdateInput $theme_update_input The updated theme (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheme'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Theme, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateThemeWithHttpInfo($merchant_id, $theme_id, $theme_update_input, string $contentType = self::contentTypes['updateTheme'][0])
    {
        $request = $this->updateThemeRequest($merchant_id, $theme_id, $theme_update_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Theme' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Theme' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Theme', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Theme';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Theme',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateThemeAsync
     *
     * Update a theme
     *
     * @param  string $merchant_id merchant ID (required)
     * @param  string $theme_id theme ID (required)
     * @param  \Rvvup\Api\Model\ThemeUpdateInput $theme_update_input The updated theme (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateThemeAsync($merchant_id, $theme_id, $theme_update_input, string $contentType = self::contentTypes['updateTheme'][0])
    {
        return $this->updateThemeAsyncWithHttpInfo($merchant_id, $theme_id, $theme_update_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateThemeAsyncWithHttpInfo
     *
     * Update a theme
     *
     * @param  string $merchant_id merchant ID (required)
     * @param  string $theme_id theme ID (required)
     * @param  \Rvvup\Api\Model\ThemeUpdateInput $theme_update_input The updated theme (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateThemeAsyncWithHttpInfo($merchant_id, $theme_id, $theme_update_input, string $contentType = self::contentTypes['updateTheme'][0])
    {
        $returnType = '\Rvvup\Api\Model\Theme';
        $request = $this->updateThemeRequest($merchant_id, $theme_id, $theme_update_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTheme'
     *
     * @param  string $merchant_id merchant ID (required)
     * @param  string $theme_id theme ID (required)
     * @param  \Rvvup\Api\Model\ThemeUpdateInput $theme_update_input The updated theme (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateThemeRequest($merchant_id, $theme_id, $theme_update_input, string $contentType = self::contentTypes['updateTheme'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling updateTheme'
            );
        }

        // verify the required parameter 'theme_id' is set
        if ($theme_id === null || (is_array($theme_id) && count($theme_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $theme_id when calling updateTheme'
            );
        }

        // verify the required parameter 'theme_update_input' is set
        if ($theme_update_input === null || (is_array($theme_update_input) && count($theme_update_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $theme_update_input when calling updateTheme'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/themes/{themeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($theme_id !== null) {
            $resourcePath = str_replace(
                '{' . 'themeId' . '}',
                ObjectSerializer::toPathValue($theme_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($theme_update_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($theme_update_input));
            } else {
                $httpBody = $theme_update_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebhook
     *
     * Update a webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  \Rvvup\Api\Model\WebhookUpdateInput $webhook_update_input The webhook to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Webhook
     */
    public function updateWebhook($merchant_id, $webhook_id, $webhook_update_input, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        list($response) = $this->updateWebhookWithHttpInfo($merchant_id, $webhook_id, $webhook_update_input, $contentType);
        return $response;
    }

    /**
     * Operation updateWebhookWithHttpInfo
     *
     * Update a webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  \Rvvup\Api\Model\WebhookUpdateInput $webhook_update_input The webhook to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Webhook, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebhookWithHttpInfo($merchant_id, $webhook_id, $webhook_update_input, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        $request = $this->updateWebhookRequest($merchant_id, $webhook_id, $webhook_update_input, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Webhook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Webhook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Webhook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Webhook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Webhook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebhookAsync
     *
     * Update a webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  \Rvvup\Api\Model\WebhookUpdateInput $webhook_update_input The webhook to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebhookAsync($merchant_id, $webhook_id, $webhook_update_input, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        return $this->updateWebhookAsyncWithHttpInfo($merchant_id, $webhook_id, $webhook_update_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebhookAsyncWithHttpInfo
     *
     * Update a webhook
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  \Rvvup\Api\Model\WebhookUpdateInput $webhook_update_input The webhook to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebhookAsyncWithHttpInfo($merchant_id, $webhook_id, $webhook_update_input, string $contentType = self::contentTypes['updateWebhook'][0])
    {
        $returnType = '\Rvvup\Api\Model\Webhook';
        $request = $this->updateWebhookRequest($merchant_id, $webhook_id, $webhook_update_input, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebhook'
     *
     * @param  string $merchant_id Merchant ID (required)
     * @param  string $webhook_id Webhook ID (required)
     * @param  \Rvvup\Api\Model\WebhookUpdateInput $webhook_update_input The webhook to update (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebhookRequest($merchant_id, $webhook_id, $webhook_update_input, string $contentType = self::contentTypes['updateWebhook'][0])
    {

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling updateWebhook'
            );
        }

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling updateWebhook'
            );
        }

        // verify the required parameter 'webhook_update_input' is set
        if ($webhook_update_input === null || (is_array($webhook_update_input) && count($webhook_update_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_update_input when calling updateWebhook'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_update_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($webhook_update_input));
            } else {
                $httpBody = $webhook_update_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voidCreditNote
     *
     * Void a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\CreditNote
     */
    public function voidCreditNote($credit_note_id, $merchant_id, string $contentType = self::contentTypes['voidCreditNote'][0])
    {
        list($response) = $this->voidCreditNoteWithHttpInfo($credit_note_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation voidCreditNoteWithHttpInfo
     *
     * Void a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidCreditNote'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\CreditNote, HTTP status code, HTTP response headers (array of strings)
     */
    public function voidCreditNoteWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['voidCreditNote'][0])
    {
        $request = $this->voidCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\CreditNote' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\CreditNote' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\CreditNote', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\CreditNote';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\CreditNote',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voidCreditNoteAsync
     *
     * Void a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidCreditNoteAsync($credit_note_id, $merchant_id, string $contentType = self::contentTypes['voidCreditNote'][0])
    {
        return $this->voidCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voidCreditNoteAsyncWithHttpInfo
     *
     * Void a credit note
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidCreditNoteAsyncWithHttpInfo($credit_note_id, $merchant_id, string $contentType = self::contentTypes['voidCreditNote'][0])
    {
        $returnType = '\Rvvup\Api\Model\CreditNote';
        $request = $this->voidCreditNoteRequest($credit_note_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'voidCreditNote'
     *
     * @param  string $credit_note_id credit note id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidCreditNote'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function voidCreditNoteRequest($credit_note_id, $merchant_id, string $contentType = self::contentTypes['voidCreditNote'][0])
    {

        // verify the required parameter 'credit_note_id' is set
        if ($credit_note_id === null || (is_array($credit_note_id) && count($credit_note_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit_note_id when calling voidCreditNote'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling voidCreditNote'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/credit-notes/{creditNoteId}/void';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($credit_note_id !== null) {
            $resourcePath = str_replace(
                '{' . 'creditNoteId' . '}',
                ObjectSerializer::toPathValue($credit_note_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voidInvoice
     *
     * Void an open invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Rvvup\Api\Model\Invoice
     */
    public function voidInvoice($invoice_id, $merchant_id, string $contentType = self::contentTypes['voidInvoice'][0])
    {
        list($response) = $this->voidInvoiceWithHttpInfo($invoice_id, $merchant_id, $contentType);
        return $response;
    }

    /**
     * Operation voidInvoiceWithHttpInfo
     *
     * Void an open invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidInvoice'] to see the possible values for this operation
     *
     * @throws \Rvvup\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Rvvup\Api\Model\Invoice, HTTP status code, HTTP response headers (array of strings)
     */
    public function voidInvoiceWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['voidInvoice'][0])
    {
        $request = $this->voidInvoiceRequest($invoice_id, $merchant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Rvvup\Api\Model\Invoice' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Rvvup\Api\Model\Invoice' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rvvup\Api\Model\Invoice', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Rvvup\Api\Model\Invoice';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rvvup\Api\Model\Invoice',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation voidInvoiceAsync
     *
     * Void an open invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidInvoiceAsync($invoice_id, $merchant_id, string $contentType = self::contentTypes['voidInvoice'][0])
    {
        return $this->voidInvoiceAsyncWithHttpInfo($invoice_id, $merchant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voidInvoiceAsyncWithHttpInfo
     *
     * Void an open invoice
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidInvoiceAsyncWithHttpInfo($invoice_id, $merchant_id, string $contentType = self::contentTypes['voidInvoice'][0])
    {
        $returnType = '\Rvvup\Api\Model\Invoice';
        $request = $this->voidInvoiceRequest($invoice_id, $merchant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'voidInvoice'
     *
     * @param  string $invoice_id invoice id (required)
     * @param  string $merchant_id merchant id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['voidInvoice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function voidInvoiceRequest($invoice_id, $merchant_id, string $contentType = self::contentTypes['voidInvoice'][0])
    {

        // verify the required parameter 'invoice_id' is set
        if ($invoice_id === null || (is_array($invoice_id) && count($invoice_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_id when calling voidInvoice'
            );
        }

        // verify the required parameter 'merchant_id' is set
        if ($merchant_id === null || (is_array($merchant_id) && count($merchant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merchant_id when calling voidInvoice'
            );
        }


        $resourcePath = '/api/2024-03-01/{merchantId}/invoices/{invoiceId}/void';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($invoice_id !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceId' . '}',
                ObjectSerializer::toPathValue($invoice_id),
                $resourcePath
            );
        }
        // path params
        if ($merchant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merchantId' . '}',
                ObjectSerializer::toPathValue($merchant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
